<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Apple macOS version 5.8.0">
  <meta charset="utf-8">
  <meta name="creator" content="RsML1">
  <meta name="author" content="Jing Huang">
  <meta name="pubdate" content="2024-08-18">
  <title>Type Theory and Formal Proof -- Some Notes Taken While Reading</title>
  <link href="/style/art.css" rel="stylesheet">
</head>
<body>
  <div class="header">
    <h1 class="title">Type Theory and Formal Proof</h1>
    <h2 class="subtitle"><em>Some Notes Taken While Reading</em></h2>
    <div class="status">
      <p>Published on 18 August 2024 by Jing Huang.</p>
    </div>
    <div class="abstract">
      <p>There notes are based on the book <em>Type Theory and Formal Proof</em> by Rob Nederpelt and Herman
      Geuvers.</p>
    </div>
    <nav id="lot">
      <h2>Table of Contents</h2>
      <div class="toc">
        <ul>
          <li>
            <a href="#c1"><span class="chapno">1</span> <span class="content">Untyped Lambda Calculus</span></a>
            <ul class="toc">
              <li>
                <a href="#s1-1"><span class="secno">1.1</span> <span class="content">Constriction Principles</span></a>
              </li>
              <li>
                <a href="#s1-2"><span class="secno">1.2</span> <span class="content">Lambda Terms</span></a>
              </li>
              <li>
                <a href="#s1-3"><span class="secno">1.3</span> <span class="content">Free and Bound
                Variables</span></a>
              </li>
              <li>
                <a href="#s1-4"><span class="secno">1.4</span> <span class="content">Alpha Conversation</span></a>
              </li>
              <li>
                <a href="#s1-5"><span class="secno">1.5</span> <span class="content">Beta Reduction</span></a>
              </li>
              <li>
                <a href="#s1-6"><span class="secno">1.6</span> <span class="content">Fixed Point Theorem</span></a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </nav>
  </div>
  <h2 id="c1">1. Untyped Lambda Calculus</h2>
  <p><em>Lambda-calculus</em> encapsulates a formation of the basic aspects of functions. Untyped lambda-calculus means
  we do not consider the types in this chapter.</p>
  <h3 id="s1-1">1.1. Constriction Principles</h3>
  <ul>
    <li>
      <em>Abstraction</em>: From an expression <math display="inline">
      <mi>
        M
      </mi></math> and a variable <math display="inline">
      <mi>
        x
      </mi></math> we can construct a new expression <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi></math>. We call this the abstraction of <math display="inline">
      <mi>
        x
      </mi></math> over <math display="inline">
      <mi>
        M
      </mi></math>.
    </li>
    <li>
      <em>Application</em>: From expressions <math display="inline">
      <mi>
        M
      </mi></math> and <math display="inline">
      <mi>
        N
      </mi></math> we can construct expression <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi></math>. We call this application of <math display="inline">
      <mi>
        M
      </mi></math> to <math display="inline">
      <mi>
        N
      </mi></math>.
    </li>
  </ul>
  <h3 id="s1-2">1.2. Lambda Terms</h3>
  <p>Expressions in the lambda calculus are called <em>lambda-terms</em>. We assume the existence of an infinite set
  <math display="inline">
  <mi>
    V
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    {
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    z
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    }
  </mo></math> of so-called <em>variables</em> while the below inductive definition establishes how the set
  <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math> of all lambda-terms are constructed:</p>
  <ol>
    <li>
      <em>Variable</em>: If <math display="inline">
      <mi>
        u
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi>
        V
      </mi></math>, then <math display="inline">
      <mi>
        u
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>.
    </li>
    <li>
      <em>Application</em>: If <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0.333em"></mspace>
      <mtext>
        and
      </mtext>
      <mspace width="0.333em"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>, then <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>.
    </li>
    <li>
      <em>Abstraction</em>: If <math display="inline">
      <mi>
        u
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi>
        V
      </mi></math> and <math display="inline">
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>, then <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        u
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>.
    </li>
  </ol>
  <p>An <em>inductive definition</em> of <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math> means that the above definitions are the only ways to construct elements of <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math>. An alternative and shorter way is to define <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math> via <em>abstract syntax</em>:</p><math display="block">
  <mi mathvariant="normal">
    Λ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi mathvariant="normal">
    Λ
  </mi>
  <mspace width="0"></mspace>
  <mi mathvariant="normal">
    Λ
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi mathvariant="normal">
    Λ
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <p>The <em>syntactical identity</em> of two lambda-terms can be denoted with the symbol <math display="inline">
  <mo>
    ≡
  </mo></math></p>
  <p>The <em>subterms</em> of a given lambda-term form a <em>multiset</em>:</p>
  <ol>
    <li>
      <em>Basis</em>: <math display="inline">
      <mtext>
        Sub
      </mtext>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        x
      </mi></math>, for each <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi>
        V
      </mi></math>.
    </li>
    <li>
      <em>Application</em>: <math display="inline">
      <mtext>
        Sub
      </mtext>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mtext>
        Sub
      </mtext>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mtext>
        Sub
      </mtext>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
    <li>
      <em>Abstraction</em>: <math display="inline">
      <mtext>
        Sub
      </mtext>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mtext>
        Sub
      </mtext>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
  </ol>
  <p>They follow <em>reflexivity</em> and <em>transitivity</em>. A proper subterm of <math display="inline">
  <mi>
    M
  </mi></math> is <math display="inline">
  <mi>
    L
  </mi></math> if <math display="inline">
  <mi>
    L
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≢
  </mo>
  <mi>
    M
  </mi></math>.</p>
  <p>The expression have the following precedence and associativity:</p>
  <ul>
    <li>Parentheses in an outermost position may be omitted.</li>
    <li>Application is <em>left-associative</em>.</li>
    <li>Application takes precedence over abstraction.</li>
    <li>Successive abstractions may be combined in a <em>right-associative</em> way under one <math display="inline">
      <mi>
        λ
      </mi></math>.
    </li>
  </ul>
  <h3 id="s1-3">1.3. Free and Bound Variables</h3>
  <p>Variable occurrences in a lambda-term can be divided into three categories: <em>free</em> occurrences,
  <em>bound</em> occurrences and <em>binding</em> occurrences.</p>
  <p>Binding variables are those occurred immediately after a <math display="inline">
  <mi>
    λ
  </mi></math>. In the construction of a lambda-term, the single variable and the variables that aren't bound by the
  binding variables are free variables. However, during the process of abstraction, an occurrence of <math display=
  "inline">
  <mi>
    x
  </mi></math> which is free in <math display="inline">
  <mi>
    M
  </mi></math> becomes bound in <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi></math>; that is, abstraction of <math display="inline">
  <mi>
    x
  </mi></math> over <math display="inline">
  <mi>
    M
  </mi></math> binds all free occurrences of <math display="inline">
  <mi>
    X
  </mi></math> in <math display="inline">
  <mi>
    M
  </mi></math>.</p>
  <p>Then we have the following recursive rule, in which <math display="inline">
  <mi>
    F
  </mi>
  <mspace width="0"></mspace>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math> denotes the set of free variables in the lambda-term <math display="inline">
  <mi>
    L
  </mi></math>.</p>
  <ol>
    <li>
      <em>Variable</em>: <math display="inline">
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
    <li>
      <em>Application</em>: <math display="inline">
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
    <li>
      <em>Abstract</em>: <math display="inline">
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        ∖
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
  </ol>
  <p>The lambda-term is <em>closed</em> if <math display="inline">
  <mi>
    F
  </mi>
  <mspace width="0"></mspace>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi mathvariant="normal">
    ∅
  </mi></math>. A closed set is also called a <em>combinator</em>. The set of all closed lambda-terms is denoted by
  <math display="inline">
  <msup>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mn>
      0
    </mn>
  </msup></math>.</p>
  <h3 id="s1-4">1.4. Alpha Conversation</h3>
  <p>Functions in the lambda-notation have the property that the <em>name</em> of the binding variable is not
  essential; the name is only used to express the transformation or procedure from input to output. Thus the relation
  <em>alpha-conversation</em> or <em>alpha-equivalence</em> is defined to describe this process formally. It's based on
  the possibility of renaming binding (and bound) variables.</p>
  <p><math display="inline">
  <msup>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        →
      </mo>
      <mi>
        y
      </mi>
    </mrow>
  </msup></math> denote the result of replacing every free occurrence of <math display="inline">
  <mi>
    x
  </mi></math> in <math display="inline">
  <mi>
    M
  </mi></math> by <math display="inline">
  <mi>
    y
  </mi></math>. The relation <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      =
    </mo>
    <mi>
      α
    </mi>
  </msub>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <msup>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        →
      </mo>
      <mi>
        y
      </mi>
    </mrow>
  </msup></math> is called <em>renaming</em>.</p>
  <p>In the renaming of <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi></math> to <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <msup>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        →
      </mo>
      <mi>
        y
      </mi>
    </mrow>
  </msup></math>, it is prevented that the <em>new</em> binding variable <math display="inline">
  <mi>
    y
  </mi></math> binds <em>old</em> free <math display="inline">
  <mi>
    y
  </mi></math>s; and that any <em>old</em> binding <math display="inline">
  <mi>
    y
  </mi></math> binds a <em>new</em> <math display="inline">
  <mi>
    y
  </mi></math>.</p>
  <p>Alpha-conversation follows <em>compatibility</em>, <em>reflectivity</em>, <em>symmetry</em> and
  <em>transitivity</em>. If <math display="inline">
  <mi>
    M
  </mi></math> and <math display="inline">
  <mi>
    N
  </mi></math> are said to be <em>alpha-convertible</em> or <em>alpha-equivalent</em>, then <math display="inline">
  <mi>
    M
  </mi></math> is called an <em>alpha-variant</em> of <math display="inline">
  <mi>
    N
  </mi></math>.</p>
  <p>We can abstract from the names of the bound (and binding) variables, by considering lambda-terms <em>modulo
  alpha-equivalence</em>.</p>
  <h3 id="s1-5">1.5. Beta Reduction</h3>
  <ol>
    <li>
      <em>Basis</em>: <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mi>
        N
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo></math>.
    </li>
    <li>
      <em>Compatibility</em>: If <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>, then <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi></math>, <math display="inline">
      <mi>
        L
      </mi>
      <mspace width="0"></mspace>
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi></math> and <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        N
      </mi></math>.
    </li>
  </ol>
  <p>The suffix <math display="inline">
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> not in lambda-terms, are meant to be <em>meta-notation</em> called substitution, which follow:</p>
  <ul>
    <li>
      <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mi>
        N
      </mi></math>, <math display="inline">
      <mi>
        y
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mi>
        y
      </mi></math> if <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ≢
      </mo>
      <mi>
        y
      </mi></math>.
    </li>
    <li>
      <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        P
      </mi>
      <mspace width="0"></mspace>
      <mi>
        Q
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        P
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        Q
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
    <li>
      <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        y
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        P
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        z
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <msup>
        <mi>
          P
        </mi>
        <mrow>
          <mi>
            y
          </mi>
          <mo lspace="0" rspace="0">
            →
          </mo>
          <mi>
            z
          </mi>
        </mrow>
      </msup>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>, if <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        z
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <msup>
        <mi>
          P
        </mi>
        <mrow>
          <mi>
            y
          </mi>
          <mo lspace="0" rspace="0">
            →
          </mo>
          <mi>
            z
          </mi>
        </mrow>
      </msup></math> is an alpha-variant of <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        y
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        P
      </mi></math> such that <math display="inline">
      <mi>
        z
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∉
      </mo>
      <mi>
        F
      </mi>
      <mspace width="0"></mspace>
      <mi>
        V
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
  </ul>
  <p>The subterm of the form <math display="inline">
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mi>
    N
  </mi></math> is called a <em>redex</em> (from reducible expression) and subterm <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> is called the <em>contractum</em> (of the redex).</p>
  <p>Note that in general, the substitutions <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> does not describe the same lambda-term as <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> because of the left associativity (<math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.278em">
    ≡
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.222em" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.222em">
    ∧
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ∉
  </mo>
  <mi>
    F
  </mi>
  <mspace width="0"></mspace>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math>).</p>
  <p>We define the relation <math display="inline">
  <msub>
    <mo>
      →
    </mo>
    <mi>
      β
    </mi>
  </msub></math> to be one-step beta-reduction since one redex is replaced by its contractum. The further
  beta-reduction performed after the one-step reduction can be defined using <math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> which generally take zero or more step. We can prove that <math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> is <em>reflective</em> and <em>transitive</em>.</p>
  <p>Similar to alpha-conversation, we can define <em>beta-conversation</em> or <em>beta-equivalence</em>. If
  <math display="inline">
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      =
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <mi>
    N
  </mi></math> and there is an <math display="inline">
  <mi>
    n
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≥
  </mo>
  <mn>
    0
  </mn></math> and there are terms <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mn>
      0
    </mn>
  </msub></math> or <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mi>
      n
    </mi>
  </msub></math> such that <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mn>
      0
    </mn>
  </msub>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    M
  </mi></math>, <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mi>
      n
    </mi>
  </msub>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    N
  </mi></math> for all <math display="inline">
  <mi>
    i
  </mi></math> such that <math display="inline">
  <mn>
    0
  </mn>
  <mo lspace="0.278em" rspace="0.278em">
    ≤
  </mo>
  <mi>
    i
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    &lt;
  </mo>
  <mi>
    n
  </mi></math>:</p><math display="block">
  <msub>
    <mi>
      M
    </mi>
    <mi>
      i
    </mi>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      →
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        i
      </mi>
      <mo lspace="0" rspace="0">
        +
      </mo>
      <mn>
        1
      </mn>
    </mrow>
  </msub>
  <mo lspace="0.222em" rspace="0.222em">
    ∨
  </mo>
  <msub>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        i
      </mi>
      <mo lspace="0" rspace="0">
        +
      </mo>
      <mn>
        1
      </mn>
    </mrow>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      →
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      M
    </mi>
    <mi>
      i
    </mi>
  </msub>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <p><math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> extends <math display="inline">
  <msub>
    <mo>
      →
    </mo>
    <mi>
      β
    </mi>
  </msub></math> to multi-steps, while <math display="inline">
  <msub>
    <mo>
      =
    </mo>
    <mi>
      β
    </mi>
  </msub></math> further extends <math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> in both directions. Thus <math display="inline">
  <msub>
    <mo>
      =
    </mo>
    <mi>
      β
    </mi>
  </msub></math> is <em>reflective</em>, <em>symmetric</em> and <em>transitive</em>.</p>
  <ul>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is in <em>beta-normal</em> form if <math display="inline">
      <mi>
        M
      </mi></math> does not contain any redex.
    </li>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is <em>beta-normalizing</em> if there is an <math display="inline">
      <mi>
        N
      </mi></math> in beta-normal form such that <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          =
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>.
    </li>
  </ul>
  <p>A <em>reduction path</em> from <math display="inline">
  <mi>
    M
  </mi></math> is an infinite or finite sequence <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      0
    </mn>
  </msub>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      1
    </mn>
  </msub>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      2
    </mn>
  </msub>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo></math> that is connected using one-step beta-reduction that starts from <math display="inline">
  <mi>
    M
  </mi></math>.</p>
  <ul>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is <em>weakly normalizing</em> if there is an <math display="inline">
      <mi>
        N
      </mi></math> in the beta-normal form such that <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          ↠
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>. (<em>One of</em> the reduction path leads to an outcome.)
    </li>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is <em>strongly normalizing</em> if there are no infinite reduction paths starting from
      <math display="inline">
      <mi>
        M
      </mi></math>. (<em>Each</em> reduction path leads to an outcome.)
    </li>
  </ul>
  <p>Suppose that for a given lambda-term <math display="inline">
  <mi>
    M
  </mi></math>, we have <math display="inline">
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mi>
      i
    </mi>
  </msub></math> and <math display="inline">
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      2
    </mn>
  </msub></math>, then there is a lambda-term <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      3
    </mn>
  </msub></math> such that <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      1
    </mn>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      3
    </mn>
  </msub></math> and <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      2
    </mn>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      3
    </mn>
  </msub></math>. This is the <em>Church-Rosser Theorem</em>.</p>
  <h3 id="s1-6">1.6. Fixed Point Theorem</h3>
  <p>Every lambda-term <math display="inline">
  <mi>
    L
  </mi></math> has a <em>fixed point</em>, which can be constructed using a <em>fixed point combinator</em>. One
  instance is:</p><math display="block">
  <mi>
    Y
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    x
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    x
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <p>Then we have <math display="inline">
  <mi>
    Y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    L
  </mi></math> which is a fixed point of <math display="inline">
  <mi>
    L
  </mi></math>, since <math display="inline">
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    Y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <msub>
    <mo lspace="0" rspace="0.278em">
      =
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <mi>
    Y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    L
  </mi></math>, which can be shown as follows:</p><math display="block">
  <mstyle scriptlevel="0">
    <mtable displaystyle="true" columnalign="right left right" columnspacing="0.2em 1em">
      <mtr>
        <mtd>
          <mi>
            Y
          </mi>
          <mspace width="0"></mspace>
          <mi>
            L
          </mi>
        </mtd>
        <mtd>
          <msub>
            <mo>
              →
            </mo>
            <mi>
              β
            </mi>
          </msub>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd></mtd>
        <mtd>
          <msub>
            <mo>
              →
            </mo>
            <mi>
              β
            </mi>
          </msub>
        </mtd>
        <mtd>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd></mtd>
        <mtd>
          <msub>
            <mo>
              =
            </mo>
            <mi>
              β
            </mi>
          </msub>
        </mtd>
        <mtd>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            Y
          </mi>
          <mspace width="0"></mspace>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0">
            .
          </mo>
        </mtd>
      </mtr>
    </mtable>
  </mstyle></math>
</body>
</html>
