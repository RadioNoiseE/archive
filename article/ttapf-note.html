<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Apple macOS version 5.8.0">
  <meta charset="utf-8">
  <meta name="creator" content="RsML1">
  <meta name="author" content="Jing Huang">
  <meta name="pubdate" content="2024-08-18">
  <title>Type Theory and Formal Proof -- Some Notes Taken While Reading</title>
  <link href="/style/art.css" rel="stylesheet">
</head>
<body>
  <div class="header">
    <h1 class="title">Type Theory and Formal Proof</h1>
    <h2 class="subtitle"><em>Some Notes Taken While Reading</em></h2>
    <div class="status">
      <p>Published on 18 August 2024 by Jing Huang.</p>
    </div>
    <div class="abstract">
      <p>There notes are based on the book <em>Type Theory and Formal Proof</em> by Rob Nederpelt and Herman
      Geuvers.</p>
    </div>
    <nav id="lot">
      <h2>Table of Contents</h2>
      <div class="toc">
        <ul>
          <li>
            <a href="#c1"><span class="chapno">1</span> <span class="content">Untyped Lambda Calculus</span></a>
            <ul class="toc">
              <li>
                <a href="#s1-1"><span class="secno">1.1</span> <span class="content">Constriction Principles</span></a>
              </li>
              <li>
                <a href="#s1-2"><span class="secno">1.2</span> <span class="content">Lambda Terms</span></a>
              </li>
              <li>
                <a href="#s1-3"><span class="secno">1.3</span> <span class="content">Free and Bound
                Variables</span></a>
              </li>
              <li>
                <a href="#s1-4"><span class="secno">1.4</span> <span class="content">Alpha Conversation</span></a>
              </li>
              <li>
                <a href="#s1-5"><span class="secno">1.5</span> <span class="content">Beta Reduction</span></a>
              </li>
              <li>
                <a href="#s1-6"><span class="secno">1.6</span> <span class="content">Fixed Point Theorem</span></a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#c2"><span class="chapno">2</span> <span class="content">Simply Typed Lambda Calculus</span></a>
            <ul class="toc">
              <li>
                <a href="#s2-1"><span class="secno">2.1</span> <span class="content">Simple Types</span></a>
              </li>
              <li>
                <a href="#s2-2"><span class="secno">2.2</span> <span class="content">Church and Curry Typing</span></a>
              </li>
              <li>
                <a href="#s2-3"><span class="secno">2.3</span> <span class="content">Derivation Rules for Churchs
                λ→</span></a>
              </li>
              <li>
                <a href="#s2-4"><span class="secno">2.4</span> <span class="content">Well-Typedness in λ→</span></a>
              </li>
              <li>
                <a href="#s2-5"><span class="secno">2.5</span> <span class="content">Type Checking in λ→</span></a>
              </li>
              <li>
                <a href="#s2-6"><span class="secno">2.6</span> <span class="content">Term Finding in λ→</span></a>
              </li>
              <li>
                <a href="#s2-7"><span class="secno">2.7</span> <span class="content">General Properties of
                λ→</span></a>
              </li>
              <li>
                <a href="#s2-8"><span class="secno">2.8</span> <span class="content">Reduction and λ→</span></a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </nav>
  </div>
  <h2 id="c1">1. Untyped Lambda Calculus</h2>
  <p><em>Lambda-calculus</em> encapsulates a formation of the basic aspects of functions. Untyped lambda-calculus means
  we do not consider the types in this chapter.</p>
  <h3 id="s1-1">1.1. Constriction Principles</h3>
  <ul>
    <li>
      <em>Abstraction</em>: From an expression <math display="inline">
      <mi>
        M
      </mi></math> and a variable <math display="inline">
      <mi>
        x
      </mi></math> we can construct a new expression <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi></math>. We call this the abstraction of <math display="inline">
      <mi>
        x
      </mi></math> over <math display="inline">
      <mi>
        M
      </mi></math>.
    </li>
    <li>
      <em>Application</em>: From expressions <math display="inline">
      <mi>
        M
      </mi></math> and <math display="inline">
      <mi>
        N
      </mi></math> we can construct expression <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi></math>. We call this application of <math display="inline">
      <mi>
        M
      </mi></math> to <math display="inline">
      <mi>
        N
      </mi></math>.
    </li>
  </ul>
  <h3 id="s1-2">1.2. Lambda Terms</h3>
  <p>Expressions in the lambda calculus are called <em>lambda-terms</em>. We assume the existence of an infinite set
  <math display="inline">
  <mi>
    V
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    {
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    z
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    }
  </mo></math> of so-called <em>variables</em> while the below inductive definition establishes how the set
  <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math> of all lambda-terms are constructed:</p>
  <ol>
    <li>
      <em>Variable</em>: If <math display="inline">
      <mi>
        u
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi>
        V
      </mi></math>, then <math display="inline">
      <mi>
        u
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>.
    </li>
    <li>
      <em>Application</em>: If <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0.333em"></mspace>
      <mtext>
        and
      </mtext>
      <mspace width="0.333em"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>, then <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>.
    </li>
    <li>
      <em>Abstraction</em>: If <math display="inline">
      <mi>
        u
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi>
        V
      </mi></math> and <math display="inline">
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>, then <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        u
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Λ
      </mi></math>.
    </li>
  </ol>
  <p>An <em>inductive definition</em> of <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math> means that the above definitions are the only ways to construct elements of <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math>. An alternative and shorter way is to define <math display="inline">
  <mi mathvariant="normal">
    Λ
  </mi></math> via <em>abstract syntax</em>:</p><math display="block">
  <mi mathvariant="normal">
    Λ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi mathvariant="normal">
    Λ
  </mi>
  <mspace width="0"></mspace>
  <mi mathvariant="normal">
    Λ
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi mathvariant="normal">
    Λ
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <p>The <em>syntactical identity</em> of two lambda-terms can be denoted with the symbol <math display="inline">
  <mo>
    ≡
  </mo></math></p>
  <p>The <em>subterms</em> of a given lambda-term form a <em>multiset</em>:</p>
  <ol>
    <li>
      <em>Basis</em>: <math display="inline">
      <mi mathvariant="script">
        S
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        x
      </mi></math>, for each <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi>
        V
      </mi></math>.
    </li>
    <li>
      <em>Application</em>: <math display="inline">
      <mi mathvariant="script">
        S
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi mathvariant="script">
        S
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mi mathvariant="script">
        S
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
    <li>
      <em>Abstraction</em>: <math display="inline">
      <mi mathvariant="script">
        S
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi mathvariant="script">
        S
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
  </ol>
  <p>They follow <em>reflexivity</em> and <em>transitivity</em>. A proper subterm of <math display="inline">
  <mi>
    M
  </mi></math> is <math display="inline">
  <mi>
    L
  </mi></math> if <math display="inline">
  <mi>
    L
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≢
  </mo>
  <mi>
    M
  </mi></math>.</p>
  <p>The expression have the following precedence and associativity:</p>
  <ul>
    <li>Parentheses in an outermost position may be omitted.</li>
    <li>Application is <em>left-associative</em>.</li>
    <li>Application takes precedence over abstraction.</li>
    <li>Successive abstractions may be combined in a <em>right-associative</em> way under one <math display="inline">
      <mi>
        λ
      </mi></math>.
    </li>
  </ul>
  <h3 id="s1-3">1.3. Free and Bound Variables</h3>
  <p>Variable occurrences in a lambda-term can be divided into three categories: <em>free</em> occurrences,
  <em>bound</em> occurrences and <em>binding</em> occurrences.</p>
  <p>Binding variables are those occurred immediately after a <math display="inline">
  <mi>
    λ
  </mi></math>. In the construction of a lambda-term, the single variable and the variables that aren't bound by the
  binding variables are free variables. However, during the process of abstraction, an occurrence of <math display=
  "inline">
  <mi>
    x
  </mi></math> which is free in <math display="inline">
  <mi>
    M
  </mi></math> becomes bound in <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi></math>; that is, abstraction of <math display="inline">
  <mi>
    x
  </mi></math> over <math display="inline">
  <mi>
    M
  </mi></math> binds all free occurrences of <math display="inline">
  <mi>
    X
  </mi></math> in <math display="inline">
  <mi>
    M
  </mi></math>.</p>
  <p>Then we have the following recursive rule, in which <math display="inline">
  <mi mathvariant="script">
    F
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math> denotes the set of free variables in the lambda-term <math display="inline">
  <mi>
    L
  </mi></math>.</p>
  <ol>
    <li>
      <em>Variable</em>: <math display="inline">
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
    <li>
      <em>Application</em>: <math display="inline">
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∪
      </mo>
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
    <li>
      <em>Abstract</em>: <math display="inline">
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        ∖
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        {
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        }
      </mo></math>.
    </li>
  </ol>
  <p>The lambda-term is <em>closed</em> if <math display="inline">
  <mi mathvariant="script">
    F
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi mathvariant="normal">
    ∅
  </mi></math>. A closed set is also called a <em>combinator</em>. The set of all closed lambda-terms is denoted by
  <math display="inline">
  <msup>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mn>
      0
    </mn>
  </msup></math>.</p>
  <h3 id="s1-4">1.4. Alpha Conversation</h3>
  <p>Functions in the lambda-notation have the property that the <em>name</em> of the binding variable is not
  essential; the name is only used to express the transformation or procedure from input to output. Thus the relation
  <em>alpha-conversation</em> or <em>alpha-equivalence</em> is defined to describe this process formally. It's based on
  the possibility of renaming binding (and bound) variables.</p>
  <p><math display="inline">
  <msup>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        →
      </mo>
      <mi>
        y
      </mi>
    </mrow>
  </msup></math> denote the result of replacing every free occurrence of <math display="inline">
  <mi>
    x
  </mi></math> in <math display="inline">
  <mi>
    M
  </mi></math> by <math display="inline">
  <mi>
    y
  </mi></math>. The relation <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      =
    </mo>
    <mi>
      α
    </mi>
  </msub>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <msup>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        →
      </mo>
      <mi>
        y
      </mi>
    </mrow>
  </msup></math> is called <em>renaming</em>.</p>
  <p>In the renaming of <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi></math> to <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <msup>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        →
      </mo>
      <mi>
        y
      </mi>
    </mrow>
  </msup></math>, it is prevented that the <em>new</em> binding variable <math display="inline">
  <mi>
    y
  </mi></math> binds <em>old</em> free <math display="inline">
  <mi>
    y
  </mi></math>s; and that any <em>old</em> binding <math display="inline">
  <mi>
    y
  </mi></math> binds a <em>new</em> <math display="inline">
  <mi>
    y
  </mi></math>.</p>
  <p>Alpha-conversation follows <em>compatibility</em>, <em>reflectivity</em>, <em>symmetry</em> and
  <em>transitivity</em>. If <math display="inline">
  <mi>
    M
  </mi></math> and <math display="inline">
  <mi>
    N
  </mi></math> are said to be <em>alpha-convertible</em> or <em>alpha-equivalent</em>, then <math display="inline">
  <mi>
    M
  </mi></math> is called an <em>alpha-variant</em> of <math display="inline">
  <mi>
    N
  </mi></math>.</p>
  <p>We can abstract from the names of the bound (and binding) variables, by considering lambda-terms <em>modulo
  alpha-equivalence</em>.</p>
  <h3 id="s1-5">1.5. Beta Reduction</h3>
  <ol>
    <li>
      <em>Basis</em>: <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mi>
        N
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo></math>.
    </li>
    <li>
      <em>Compatibility</em>: If <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>, then <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi></math>, <math display="inline">
      <mi>
        L
      </mi>
      <mspace width="0"></mspace>
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi></math> and <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        N
      </mi></math>.
    </li>
  </ol>
  <p>The suffix <math display="inline">
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> not in lambda-terms, are meant to be <em>meta-notation</em> called substitution, which follow:</p>
  <ul>
    <li>
      <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mi>
        N
      </mi></math>, <math display="inline">
      <mi>
        y
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mi>
        y
      </mi></math> if <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ≢
      </mo>
      <mi>
        y
      </mi></math>.
    </li>
    <li>
      <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        P
      </mi>
      <mspace width="0"></mspace>
      <mi>
        Q
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        P
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        Q
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
    <li>
      <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        y
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        P
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0.278em">
        ≡
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        z
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <msup>
        <mi>
          P
        </mi>
        <mrow>
          <mi>
            y
          </mi>
          <mo lspace="0" rspace="0">
            →
          </mo>
          <mi>
            z
          </mi>
        </mrow>
      </msup>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>, if <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        z
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <msup>
        <mi>
          P
        </mi>
        <mrow>
          <mi>
            y
          </mi>
          <mo lspace="0" rspace="0">
            →
          </mo>
          <mi>
            z
          </mi>
        </mrow>
      </msup></math> is an alpha-variant of <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        y
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        P
      </mi></math> such that <math display="inline">
      <mi>
        z
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∉
      </mo>
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
  </ul>
  <p>The subterm of the form <math display="inline">
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mi>
    N
  </mi></math> is called a <em>redex</em> (from reducible expression) and subterm <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> is called the <em>contractum</em> (of the redex).</p>
  <p>Note that in general, the substitutions <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> does not describe the same lambda-term as <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo></math> because of the left associativity (<math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.278em">
    ≡
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.222em" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.222em">
    ∧
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ∉
  </mo>
  <mi mathvariant="script">
    F
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math>).</p>
  <p>We define the relation <math display="inline">
  <msub>
    <mo>
      →
    </mo>
    <mi>
      β
    </mi>
  </msub></math> to be one-step beta-reduction since one redex is replaced by its contractum. The further
  beta-reduction performed after the one-step reduction can be defined using <math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> which generally take zero or more step. We can prove that <math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> is <em>reflective</em> and <em>transitive</em>.</p>
  <p>Similar to alpha-conversation, we can define <em>beta-conversation</em> or <em>beta-equivalence</em>. If
  <math display="inline">
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      =
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <mi>
    N
  </mi></math> and there is an <math display="inline">
  <mi>
    n
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≥
  </mo>
  <mn>
    0
  </mn></math> and there are terms <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mn>
      0
    </mn>
  </msub></math> or <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mi>
      n
    </mi>
  </msub></math> such that <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mn>
      0
    </mn>
  </msub>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    M
  </mi></math>, <math display="inline">
  <msub>
    <mi>
      M
    </mi>
    <mi>
      n
    </mi>
  </msub>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    N
  </mi></math> for all <math display="inline">
  <mi>
    i
  </mi></math> such that <math display="inline">
  <mn>
    0
  </mn>
  <mo lspace="0.278em" rspace="0.278em">
    ≤
  </mo>
  <mi>
    i
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    &lt;
  </mo>
  <mi>
    n
  </mi></math>:</p><math display="block">
  <msub>
    <mi>
      M
    </mi>
    <mi>
      i
    </mi>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      →
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        i
      </mi>
      <mo lspace="0" rspace="0">
        +
      </mo>
      <mn>
        1
      </mn>
    </mrow>
  </msub>
  <mo lspace="0.222em" rspace="0.222em">
    ∨
  </mo>
  <msub>
    <mi>
      M
    </mi>
    <mrow>
      <mi>
        i
      </mi>
      <mo lspace="0" rspace="0">
        +
      </mo>
      <mn>
        1
      </mn>
    </mrow>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      →
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      M
    </mi>
    <mi>
      i
    </mi>
  </msub>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <p><math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> extends <math display="inline">
  <msub>
    <mo>
      →
    </mo>
    <mi>
      β
    </mi>
  </msub></math> to multi-steps, while <math display="inline">
  <msub>
    <mo>
      =
    </mo>
    <mi>
      β
    </mi>
  </msub></math> further extends <math display="inline">
  <msub>
    <mo>
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub></math> in both directions. Thus <math display="inline">
  <msub>
    <mo>
      =
    </mo>
    <mi>
      β
    </mi>
  </msub></math> is <em>reflective</em>, <em>symmetric</em> and <em>transitive</em>.</p>
  <ul>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is in <em>beta-normal</em> form if <math display="inline">
      <mi>
        M
      </mi></math> does not contain any redex.
    </li>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is <em>beta-normalizing</em> if there is an <math display="inline">
      <mi>
        N
      </mi></math> in beta-normal form such that <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          =
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>.
    </li>
  </ul>
  <p>A <em>reduction path</em> from <math display="inline">
  <mi>
    M
  </mi></math> is an infinite or finite sequence <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      0
    </mn>
  </msub>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      1
    </mn>
  </msub>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      2
    </mn>
  </msub>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo></math> that is connected using one-step beta-reduction that starts from <math display="inline">
  <mi>
    M
  </mi></math>.</p>
  <ul>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is <em>weakly normalizing</em> if there is an <math display="inline">
      <mi>
        N
      </mi></math> in the beta-normal form such that <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          ↠
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>. (<em>One of</em> the reduction path leads to an outcome.)
    </li>
    <li>
      <math display="inline">
      <mi>
        M
      </mi></math> is <em>strongly normalizing</em> if there are no infinite reduction paths starting from
      <math display="inline">
      <mi>
        M
      </mi></math>. (<em>Each</em> reduction path leads to an outcome.)
    </li>
  </ul>
  <p>Suppose that for a given lambda-term <math display="inline">
  <mi>
    M
  </mi></math>, we have <math display="inline">
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mi>
      i
    </mi>
  </msub></math> and <math display="inline">
  <mi>
    M
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      2
    </mn>
  </msub></math>, then there is a lambda-term <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      3
    </mn>
  </msub></math> such that <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      1
    </mn>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      3
    </mn>
  </msub></math> and <math display="inline">
  <msub>
    <mi>
      N
    </mi>
    <mn>
      2
    </mn>
  </msub>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msub>
    <mi>
      N
    </mi>
    <mn>
      3
    </mn>
  </msub></math>. This is the <em>Church-Rosser Theorem</em>.</p>
  <h3 id="s1-6">1.6. Fixed Point Theorem</h3>
  <p>Every lambda-term <math display="inline">
  <mi>
    L
  </mi></math> has a <em>fixed point</em>, which can be constructed using a <em>fixed point combinator</em>. One
  instance is:</p><math display="block">
  <mi>
    Y
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    x
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    x
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <p>Then we have <math display="inline">
  <mi>
    Y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    L
  </mi></math> which is a fixed point of <math display="inline">
  <mi>
    L
  </mi></math>, since <math display="inline">
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    Y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <msub>
    <mo lspace="0" rspace="0.278em">
      =
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <mi>
    Y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    L
  </mi></math>, which can be shown as follows:</p><math display="block">
  <mstyle scriptlevel="0">
    <mtable displaystyle="true" columnalign="right left right" columnspacing="0.2em 1em">
      <mtr>
        <mtd>
          <mi>
            Y
          </mi>
          <mspace width="0"></mspace>
          <mi>
            L
          </mi>
        </mtd>
        <mtd>
          <msub>
            <mo>
              →
            </mo>
            <mi>
              β
            </mi>
          </msub>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd></mtd>
        <mtd>
          <msub>
            <mo>
              →
            </mo>
            <mi>
              β
            </mi>
          </msub>
        </mtd>
        <mtd>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            λ
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            x
          </mi>
          <mspace width="0"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd></mtd>
        <mtd>
          <msub>
            <mo>
              =
            </mo>
            <mi>
              β
            </mi>
          </msub>
        </mtd>
        <mtd>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            Y
          </mi>
          <mspace width="0"></mspace>
          <mi>
            L
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
          <mo lspace="0" rspace="0">
            .
          </mo>
        </mtd>
      </mtr>
    </mtable>
  </mstyle></math>
  <h2 id="c2">2. Simply Typed Lambda Calculus</h2>
  <p>In order to get a firmer hold on the desired behavior of functions, we introduce <em>types</em>. Functions are
  been classified to a certain collection, and certain restrictions on the input values are given.</p>
  <p>The <em>simple types</em> introduced in this chapter prevents the anomalies but are also in several senses too
  restrictive. We will enlarge the expressivity of the system in subsequent chapters.</p>
  <h3 id="s2-1">2.1. Simple Types</h3>
  <p>We first define an infinite set of type <em>variables</em> <math display="inline">
  <mi mathvariant="double-struck">
    V
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    {
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    γ
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    }
  </mo>
  <mo lspace="0" rspace="0">
    .
  </mo></math> and then define the set of simple types <math display="inline">
  <mi mathvariant="double-struck">
    T
  </mi></math>:</p>
  <ol>
    <li>
      <em>Type variable</em>: If <math display="inline">
      <mi>
        α
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="double-struck">
        V
      </mi></math>, then <math display="inline">
      <mi>
        α
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="double-struck">
        T
      </mi></math>.
    </li>
    <li>
      <em>Arrow type</em>: If <math display="inline">
      <mi>
        σ
      </mi>
      <mo lspace="0" rspace="0.167em">
        ,
      </mo>
      <mi>
        τ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="double-struck">
        T
      </mi></math>, then <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        τ
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="double-struck">
        T
      </mi></math>.
    </li>
  </ol>
  <p>It can be expressed using abstract syntax as <math display="inline">
  <mi mathvariant="double-struck">
    T
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mi mathvariant="double-struck">
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mi mathvariant="double-struck">
    T
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi mathvariant="double-struck">
    T
  </mi></math>.</p>
  <p>The Greek letters <math display="inline">
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    γ
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo></math> and variants are used for type variables belonging to <math display="inline">
  <mi mathvariant="double-struck">
    V
  </mi></math>. Arbitrary simple types are denoted using <math display="inline">
  <mi>
    σ
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    τ
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mo lspace="0" rspace="0">
    …
  </mo></math>. Their outermost parentheses may be <em>omitted</em> and for arrow-types, they are
  <em>right-associative</em>.</p>
  <p>Type variables are abstract representations of <em>basic types</em>, such as <math display="inline">
  <mi>
    n
  </mi>
  <mspace width="0"></mspace>
  <mi>
    a
  </mi>
  <mspace width="0"></mspace>
  <mi>
    t
  </mi></math> for natural numbers or <math display="inline">
  <mi>
    l
  </mi>
  <mspace width="0"></mspace>
  <mi>
    i
  </mi>
  <mspace width="0"></mspace>
  <mi>
    s
  </mi>
  <mspace width="0"></mspace>
  <mi>
    t
  </mi></math> for lists. Arrow types represent <em>function types</em>, such as <math display="inline">
  <mi>
    n
  </mi>
  <mspace width="0"></mspace>
  <mi>
    a
  </mi>
  <mspace width="0"></mspace>
  <mi>
    t
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    r
  </mi>
  <mspace width="0"></mspace>
  <mi>
    e
  </mi>
  <mspace width="0"></mspace>
  <mi>
    a
  </mi>
  <mspace width="0"></mspace>
  <mi>
    l
  </mi></math> which abstracts a function which input is a natural number and the returned result is a real number.</p>
  <p>We also have <em>statements</em> which allow us to express something like <q>term <math display="inline">
  <mi>
    M
  </mi></math> has type <math display="inline">
  <mi>
    σ
  </mi></math></q> in the form <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math>. We assume we have infinitude of variables available for each type <math display="inline">
  <mi>
    σ
  </mi></math>, thus we assume that each variable <math display="inline">
  <mi>
    x
  </mi></math> has a unique type: if <math display="inline">
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math> and <math display="inline">
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    τ
  </mi></math>, then <math display="inline">
  <mi>
    σ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    τ
  </mi></math>.</p>
  <p>By adding typing to the basic construction principles of lambda calculus, we have:</p>
  <ol>
    <li>
      <em>Application</em>: If <math display="inline">
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        τ
      </mi></math> and <math display="inline">
      <mi>
        N
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>, then <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        τ
      </mi></math>.
    </li>
    <li>
      <em>Abstraction</em>: If <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math> and <math display="inline">
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        τ
      </mi></math>, then <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        τ
      </mi></math>.
    </li>
  </ol>
  <p>There are two <em>side conditions</em> which have to be satisfied in the typing of an application <math display=
  "inline">
  <mi>
    M
  </mi>
  <mspace width="0"></mspace>
  <mi>
    N
  </mi></math>: the left-hand side <math display="inline">
  <mi>
    M
  </mi></math> of the application must have a function type <math display="inline">
  <mi>
    σ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    τ
  </mi></math> while the right-hand side <math display="inline">
  <mi>
    N
  </mi></math> of the application must match with the input type <math display="inline">
  <mi>
    σ
  </mi></math>; the output type will then be <math display="inline">
  <mi>
    τ
  </mi></math>. For abstraction <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    M
  </mi></math>, we just need the types of <math display="inline">
  <mi>
    x
  </mi></math> and <math display="inline">
  <mi>
    M
  </mi></math>.</p>
  <p>A term <math display="inline">
  <mi>
    M
  </mi></math> is called <em>typable</em> if there is a type <math display="inline">
  <mi>
    σ
  </mi></math> such that <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math>.</p>
  <h3 id="s2-2">2.2. Church and Curry Typing</h3>
  <p>To type a lambda term, we should first type its variables. We can give types to variables in two ways:</p>
  <ol>
    <li><em>Typing à la Church</em>: also called <em>explicit typing</em>, that we prescribe a (unique) type for each
    variable upon its introduction.</li>
    <li><em>Typing à la Curry</em>: also called <em>implicit typing</em>, which type is left open to some extent. We
    find typable terms by a search process, which may involve guesses for the types of the variables.</li>
  </ol>
  <p>We denote the types of bound variables immediately after their introduction following a <math display="inline">
  <mi>
    λ
  </mi></math> while the types of free variables are given in a so-called <em>context</em>
  (<em>basis</em>):</p><math display="block">
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    u
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    γ
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    z
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    x
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    :
  </mo>
  <mi>
    γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo></math>
  <h3 id="s2-3">2.3. Derivation Rules for Church's <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math></h3>
  <p>The definition of lambda terms have to be modified to incorporate type information. This new set of pre-typed
  <math display="inline">
  <msub>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mi mathvariant="double-struck">
      T
    </mi>
  </msub></math> is defined by <math display="inline">
  <msub>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mi mathvariant="double-struck">
      T
    </mi>
  </msub>
  <mo lspace="0.278em" rspace="0.278em">
    =
  </mo>
  <mi>
    V
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <msub>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mi mathvariant="double-struck">
      T
    </mi>
  </msub>
  <mspace width="0"></mspace>
  <msub>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mi mathvariant="double-struck">
      T
    </mi>
  </msub>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    |
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    V
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi mathvariant="double-struck">
    T
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <msub>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mi mathvariant="double-struck">
      T
    </mi>
  </msub>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math>.</p>
  <p>A <em>judgment</em> has the form <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math>, with <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi></math> a context and <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math> a statement.</p>
  <ol>
    <li>
      <em>Statement</em>: <math display="inline">
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>, where <math display="inline">
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <msub>
        <mi mathvariant="normal">
          Λ
        </mi>
        <mi mathvariant="double-struck">
          T
        </mi>
      </msub></math> and <math display="inline">
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="double-struck">
        T
      </mi></math>.
    </li>
    <li><em>Declaration</em>: a statement with a variable as subject.</li>
    <li><em>Context</em>: a list of declarations with different subjects.</li>
  </ol>
  <p>Below we give three <em>derivation rules</em> to form a so-called <em>derivation system</em> for Church's
  <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math> in the <em>premiss-conclusion</em> format.</p><math display="block">
  <mstyle scriptlevel="0">
    <mtable displaystyle="true" columnalign="right left" columnspacing="0.2em">
      <mtr>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            v
          </mi>
          <mspace width="0"></mspace>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            r
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
        <mtd>
          <mi>
            γ
          </mi>
          <mo lspace="0.278em" rspace="0.278em">
            ⊢
          </mo>
          <mi>
            x
          </mi>
          <mo lspace="0.278em" rspace="0.278em">
            :
          </mo>
          <mi>
            σ
          </mi>
          <mspace width="0.333em"></mspace>
          <mtext>
            if
          </mtext>
          <mspace width="0.333em"></mspace>
          <mi>
            x
          </mi>
          <mo lspace="0.278em" rspace="0.278em">
            :
          </mo>
          <mi>
            σ
          </mi>
          <mo lspace="0.278em" rspace="0.278em">
            ∈
          </mo>
          <mi mathvariant="normal">
            Γ
          </mi>
          <mo lspace="0" rspace="0">
            .
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            l
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
        <mtd>
          <mfrac>
            <mrow>
              <mi mathvariant="normal">
                Γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                M
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                σ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                τ
              </mi>
              <mspace width="1.000em"></mspace>
              <mi>
                γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                N
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                σ
              </mi>
            </mrow>
            <mrow>
              <mi mathvariant="normal">
                Γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                M
              </mi>
              <mspace width="0"></mspace>
              <mi>
                N
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                τ
              </mi>
            </mrow>
          </mfrac>
          <mo lspace="0" rspace="0">
            .
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            b
          </mi>
          <mspace width="0"></mspace>
          <mi>
            s
          </mi>
          <mspace width="0"></mspace>
          <mi>
            t
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
        <mtd>
          <mfrac>
            <mrow>
              <mi>
                γ
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                σ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                M
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                τ
              </mi>
            </mrow>
            <mrow>
              <mi mathvariant="normal">
                Γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                σ
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                M
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                σ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                τ
              </mi>
            </mrow>
          </mfrac>
          <mo lspace="0" rspace="0">
            .
          </mo>
        </mtd>
      </mtr>
    </mtable>
  </mstyle></math>
  <p>A pre-typed term <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math> is called <em>legal</em> if there exist context <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi></math> and type <math display="inline">
  <mi>
    ρ
  </mi></math> such that <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    ρ
  </mi></math>.</p>
  <h3 id="s2-4">2.4. Well-Typedness in <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math></h3>
  <p>This is one of the three problems connected with judgments in type theory: to find an appropriate context and type
  if the term is indeed legal.</p>
  <p>For example, we want to show <math display="inline">
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi></math> is valid. Hence, our task is to find a type <math display="inline">
  <mi>
    ρ
  </mi></math> such that <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    ρ
  </mi></math>. First we determine the context <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi></math> which <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi mathvariant="normal">
    ∅
  </mi></math> suffices since there are no free variables in <math display="inline">
  <mi>
    M
  </mi></math>. Then we need to find <math display="inline">
  <mi>
    ρ
  </mi></math>.</p><math display="block">
  <mstyle scriptlevel="0">
    <mtable displaystyle="true" columnalign="right left" columnspacing="0.2em">
      <mtr>
        <mtd>
          <mfrac>
            <mrow>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mspace width="1.000em"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
            </mrow>
            <mrow>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
            </mrow>
          </mfrac>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            l
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mfrac>
            <mrow>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
            </mrow>
            <mrow>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
            </mrow>
          </mfrac>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            b
          </mi>
          <mspace width="0"></mspace>
          <mi>
            s
          </mi>
          <mspace width="0"></mspace>
          <mi>
            t
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mfrac>
            <mrow>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
            </mrow>
            <mrow>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0.278em" stretchy="false">
                )
              </mo>
              <mo lspace="0" rspace="0.278em">
                →
              </mo>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0" stretchy="false">
                )
              </mo>
            </mrow>
          </mfrac>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            b
          </mi>
          <mspace width="0"></mspace>
          <mi>
            s
          </mi>
          <mspace width="0"></mspace>
          <mi>
            t
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
    </mtable>
  </mstyle></math>
  <p>Thus we can conclude that <math display="inline">
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    y
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi></math> is valid since we find <math display="inline">
  <mi>
    ρ
  </mi></math> which is <math display="inline">
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    →
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math>.</p>
  <h3 id="s2-5">2.5. Type Checking in <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math></h3>
  <p>The name type checking is straightforward, it means to check the validity of a full judgment.</p>
  <p>In order to illustrate this matter, we construct a derivation for <math display="inline">
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    y
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    α
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    β
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    λ
  </mi>
  <mspace width="0"></mspace>
  <mi>
    u
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    γ
  </mi>
  <mo lspace="0" rspace="0">
    .
  </mo>
  <mi>
    z
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    y
  </mi>
  <mspace width="0"></mspace>
  <mi>
    z
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    :
  </mo>
  <mi>
    γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    β
  </mi></math>:</p><math display="block">
  <mstyle scriptlevel="0">
    <mtable displaystyle="true" columnalign="right left" columnspacing="0.2em">
      <mtr>
        <mtd>
          <mfrac>
            <mrow>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                α
              </mi>
              <mspace width="1.000em"></mspace>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0.278em" stretchy="false">
                )
              </mo>
              <mo lspace="0" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
            </mrow>
            <mrow>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0.278em" stretchy="false">
                )
              </mo>
              <mo lspace="0" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
            </mrow>
          </mfrac>
          <mspace width="1.000em"></mspace>
          <mfrac>
            <mrow>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mspace width="1.000em"></mspace>
              <mi>
                u
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
            </mrow>
            <mrow>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                u
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                u
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
            </mrow>
          </mfrac>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            l
          </mi>
          <mo lspace="0" rspace="0.167em">
            ,
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            b
          </mi>
          <mspace width="0"></mspace>
          <mi>
            s
          </mi>
          <mspace width="0"></mspace>
          <mi>
            t
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
      <mtr>
        <mtd>
          <mfrac>
            <mrow>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                y
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                α
              </mi>
              <mo lspace="0" rspace="0.278em" stretchy="false">
                )
              </mo>
              <mo lspace="0" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                x
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mspace width="1.000em"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0.167em">
                ,
              </mo>
              <mi>
                u
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                ⊢
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                u
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
            </mrow>
            <mrow>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                z
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                β
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                λ
              </mi>
              <mspace width="0"></mspace>
              <mi>
                u
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0" rspace="0">
                .
              </mo>
              <mi>
                z
              </mi>
              <mo lspace="0" rspace="0" stretchy="false">
                )
              </mo>
              <mo lspace="0" rspace="0" stretchy="false">
                (
              </mo>
              <mi>
                y
              </mi>
              <mspace width="0"></mspace>
              <mi>
                x
              </mi>
              <mo lspace="0" rspace="0.278em" stretchy="false">
                )
              </mo>
              <mo lspace="0" rspace="0.278em">
                :
              </mo>
              <mi>
                γ
              </mi>
              <mo lspace="0.278em" rspace="0.278em">
                →
              </mo>
              <mi>
                β
              </mi>
            </mrow>
          </mfrac>
        </mtd>
        <mtd>
          <mo lspace="0" rspace="0" stretchy="false">
            (
          </mo>
          <mi>
            a
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            p
          </mi>
          <mspace width="0"></mspace>
          <mi>
            l
          </mi>
          <mo lspace="0" rspace="0" stretchy="false">
            )
          </mo>
        </mtd>
      </mtr>
    </mtable>
  </mstyle></math>
  <p>Hence we have succeeded in giving a proper deviation of the judgment.</p>
  <h3 id="s2-6">2.6. Term Finding in <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math></h3>
  <p>This section presents the third of the general problem in type theory, namely to find an appropriate term of a
  certain type, in a certain context. A term which belongs to a certain type is called an <em>inhabitant</em> of that
  type.</p>
  <p>To find an inhabitant of a certain type, we can think of the type as <em>proposition</em>, while each inhabitant
  codes a <em>proof</em> of this proposition.</p>
  <p>For instance, to find the term of <math display="inline">
  <mi>
    A
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    B
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    →
  </mo>
  <mi>
    A
  </mi></math>, we can follow:</p>
  <ol>
    <li>Assume that <math display="inline">
      <mi>
        x
      </mi></math> is a proof of proposition <math display="inline">
      <mi>
        A
      </mi></math>.
    </li>
    <li>Also assume that <math display="inline">
      <mi>
        y
      </mi></math> is a proof of proposition <math display="inline">
      <mi>
        B
      </mi></math>.
    </li>
    <li>Then <math display="inline">
      <mi>
        x
      </mi></math> is still a proof of <math display="inline">
      <mi>
        A
      </mi></math>.
    </li>
    <li>So the function mapping <math display="inline">
      <mi>
        y
      </mi></math> to <math display="inline">
      <mi>
        x
      </mi></math> sends a proof of <math display="inline">
      <mi>
        B
      </mi></math> to a proof of <math display="inline">
      <mi>
        A
      </mi></math>, i.e., <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        y
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        B
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        x
      </mi></math> proves the implication <math display="inline">
      <mi>
        B
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        A
      </mi></math>.
    </li>
    <li>Consequently, <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        z
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        A
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        y
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        B
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        x
      </mi></math> proves <math display="inline">
      <mi>
        A
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        B
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        A
      </mi></math>.
    </li>
  </ol>
  <p>The above process is generally called the <em>PAT-interpretation</em>, where PAT means both
  <q>propositions-as-types</q> and <q>proofs-as-terms</q>.</p>
  <h3 id="s2-7">2.7. General Properties of <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math></h3>
  <p>We give a number of definitions about context below:</p>
  <ol>
    <li>If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ≡
      </mo>
      <msub>
        <mi>
          x
        </mi>
        <mn>
          1
        </mn>
      </msub>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <msub>
        <mi>
          σ
        </mi>
        <mn>
          1
        </mn>
      </msub>
      <mo lspace="0" rspace="0.167em">
        ,
      </mo>
      <mo lspace="0" rspace="0.167em">
        …
      </mo>
      <mo lspace="0" rspace="0.167em">
        ,
      </mo>
      <msub>
        <mi>
          x
        </mi>
        <mi>
          n
        </mi>
      </msub>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <msub>
        <mi>
          σ
        </mi>
        <mi>
          n
        </mi>
      </msub></math>, then the <em>domain</em> of <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math> or <math display="inline">
      <mi mathvariant="script">
        D
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math> is the list <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <msub>
        <mi>
          x
        </mi>
        <mn>
          1
        </mn>
      </msub>
      <mo lspace="0" rspace="0.167em">
        ,
      </mo>
      <mo lspace="0" rspace="0.167em">
        …
      </mo>
      <mo lspace="0" rspace="0.167em">
        ,
      </mo>
      <msub>
        <mi>
          x
        </mi>
        <mi>
          n
        </mi>
      </msub>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo></math>.
    </li>
    <li>Context <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> is a <em>subcontext</em> of context <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math>, or <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup>
      <mo lspace="0.278em" rspace="0.278em">
        ⊆
      </mo>
      <mi mathvariant="normal">
        Γ
      </mi></math>, if all declarations occurring in <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> also occur in <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math>, in the same order.
    </li>
    <li>Context <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> is a <em>permutation</em> of context <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math>, if all declarations in <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> also occur in <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math>, and vice versa.
    </li>
    <li>If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math> is a context and <math display="inline">
      <mi mathvariant="normal">
        Φ
      </mi></math> is a set of variables, then the <em>projection</em> of <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math> on <math display="inline">
      <mi mathvariant="normal">
        Φ
      </mi></math>, or <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ↾
      </mo>
      <mi mathvariant="normal">
        Φ
      </mi></math>, is the subcontext <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> of <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math> with <math display="inline">
      <mi mathvariant="script">
        D
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi mathvariant="script">
        D
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0" rspace="0.222em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.222em">
        ∩
      </mo>
      <mi mathvariant="normal">
        Φ
      </mi></math>.
    </li>
  </ol>
  <p>An important property concerning the free variables occurring in a judgment is that if <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math>, then <math display="inline">
  <mi mathvariant="script">
    F
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    )
  </mo>
  <mo lspace="0" rspace="0.278em">
    ⊆
  </mo>
  <mi mathvariant="script">
    D
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    (
  </mo>
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    )
  </mo></math>. This can be proved by induction on the deviation of the judgment <math display="inline">
  <mi mathvariant="script">
    J
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ≡
  </mo>
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math>.</p>
  <p>We continue with three other properties which are trivial and can also be proved by induction.</p>
  <ol>
    <li>
      <em>Thinning</em>: Let <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> and <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mrow>
          <mo lspace="0" rspace="0">
            ′
          </mo>
          <mo lspace="0" rspace="0">
            ′
          </mo>
        </mrow>
      </msup></math> be contexts such that <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup>
      <mo lspace="0.278em" rspace="0.278em">
        ⊆
      </mo>
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mrow>
          <mo lspace="0" rspace="0">
            ′
          </mo>
          <mo lspace="0" rspace="0">
            ′
          </mo>
        </mrow>
      </msup></math>. If <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>, then also <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mrow>
          <mo lspace="0" rspace="0">
            ′
          </mo>
          <mo lspace="0" rspace="0">
            ′
          </mo>
        </mrow>
      </msup>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>.
    </li>
    <li>
      <em>Condensing</em>: If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>, then also <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ↾
      </mo>
      <mi mathvariant="script">
        F
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0.278em" stretchy="false">
        )
      </mo>
      <mo lspace="0" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>.
    </li>
    <li>
      <em>Permutation</em>: If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>, and <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> is a permutation of <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi></math>, then <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup></math> is also a context and moreover, <math display="inline">
      <msup>
        <mi mathvariant="normal">
          Γ
        </mi>
        <mo lspace="0" rspace="0">
          ′
        </mo>
      </msup>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>.
    </li>
  </ol>
  <p>The <em>Generation Lemma</em>, which says precisely how a certain judgment can be generated, is shown below:</p>
  <ol>
    <li>If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>, then <math display="inline">
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ∈
      </mo>
      <mi mathvariant="normal">
        Γ
      </mi></math>.
    </li>
    <li>If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        N
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        τ
      </mi></math>, then there is a type <math display="inline">
      <mi>
        σ
      </mi></math> such that <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        τ
      </mi></math> and <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi></math>.
    </li>
    <li>If <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        ρ
      </mi></math>, then there is <math display="inline">
      <mi>
        τ
      </mi></math> such that <math display="inline">
      <mi mathvariant="normal">
        Γ
      </mi>
      <mo lspace="0" rspace="0.167em">
        ,
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ⊢
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        τ
      </mi></math> and <math display="inline">
      <mi>
        ρ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        ≡
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        →
      </mo>
      <mi>
        τ
      </mi></math>.
    </li>
  </ol>
  <p>It's obvious that, in order to build a legal term, its subterms should be legal too. This is the <em>Subterm
  Lemma</em>.</p>
  <p>Another important property which applies for Church's <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math> is that, a term may have <em>at most one</em> type. This ensures that the type, if exists, must be
  unique. Therefore we also have the <em>uniqueness of types</em>.</p>
  <h3 id="s2-8">2.8. Reduction and <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math></h3>
  <p>In order to be able to treat substitution, an operation at the heart of beta-reduction, in <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math>, we have to append type information. We then have the <em>Substitution Lemma</em>: assume <math display=
  "inline">
  <msup>
    <mi mathvariant="normal">
      Γ
    </mi>
    <mo lspace="0" rspace="0">
      ′
    </mo>
  </msup>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <msup>
    <mi mathvariant="normal">
      Γ
    </mi>
    <mrow>
      <mo lspace="0" rspace="0">
        ′
      </mo>
      <mo lspace="0" rspace="0">
        ′
      </mo>
    </mrow>
  </msup>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    τ
  </mi></math> and <math display="inline">
  <msup>
    <mi mathvariant="normal">
      Γ
    </mi>
    <mo lspace="0" rspace="0">
      ′
    </mo>
  </msup>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    σ
  </mi></math>; then <math display="inline">
  <msup>
    <mi mathvariant="normal">
      Γ
    </mi>
    <mo lspace="0" rspace="0">
      ′
    </mo>
  </msup>
  <mo lspace="0" rspace="0.167em">
    ,
  </mo>
  <msup>
    <mi mathvariant="normal">
      Γ
    </mi>
    <mrow>
      <mo lspace="0" rspace="0">
        ′
      </mo>
      <mo lspace="0" rspace="0">
        ′
      </mo>
    </mrow>
  </msup>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    M
  </mi>
  <mo lspace="0" rspace="0" stretchy="false">
    [
  </mo>
  <mi>
    x
  </mi>
  <mo lspace="0.278em" rspace="0">
    :
  </mo>
  <mo lspace="0" rspace="0.278em">
    =
  </mo>
  <mi>
    N
  </mi>
  <mo lspace="0" rspace="0.278em" stretchy="false">
    ]
  </mo>
  <mo lspace="0" rspace="0.278em">
    :
  </mo>
  <mi>
    τ
  </mi></math>. This means that if we substitute all occurrences of context variable by a term of the same type, the
  result type is unchanged which is intuitively understandable.</p>
  <p>We also have to adjust the definition for beta-reduction to the (pre-typed) terms of <math display="inline">
  <msub>
    <mi mathvariant="normal">
      Λ
    </mi>
    <mi mathvariant="double-struck">
      T
    </mi>
  </msub></math>:</p>
  <ol>
    <li>
      <em>Basis</em>: <math display="inline">
      <mo lspace="0" rspace="0" stretchy="false">
        (
      </mo>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        σ
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        )
      </mo>
      <mi>
        N
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        M
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        [
      </mo>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0">
        :
      </mo>
      <mo lspace="0" rspace="0.278em">
        =
      </mo>
      <mi>
        N
      </mi>
      <mo lspace="0" rspace="0" stretchy="false">
        ]
      </mo></math>.
    </li>
    <li>
      <em>Compatibility</em>: If <math display="inline">
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi></math>, then <math display="inline">
      <mi>
        M
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi></math>, <math display="inline">
      <mi>
        L
      </mi>
      <mspace width="0"></mspace>
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        N
      </mi>
      <mspace width="0"></mspace>
      <mi>
        L
      </mi></math> and <math display="inline">
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        τ
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        M
      </mi>
      <msub>
        <mo lspace="0.278em" rspace="0.278em">
          →
        </mo>
        <mi>
          β
        </mi>
      </msub>
      <mi>
        λ
      </mi>
      <mspace width="0"></mspace>
      <mi>
        x
      </mi>
      <mo lspace="0.278em" rspace="0.278em">
        :
      </mo>
      <mi>
        τ
      </mi>
      <mo lspace="0" rspace="0">
        .
      </mo>
      <mi>
        N
      </mi></math>.
    </li>
  </ol>
  <p>The Church-Rosser Theorem is still valid as types clearly play no role in the reduction process.</p>
  <p>The <em>Subject Reduction</em> states that beta-reduction does not affect typability, and even does not change the
  term's type: if <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <mi>
    L
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    ρ
  </mi></math> and if <math display="inline">
  <mi>
    L
  </mi>
  <msub>
    <mo lspace="0.278em" rspace="0.278em">
      ↠
    </mo>
    <mi>
      β
    </mi>
  </msub>
  <msup>
    <mi>
      L
    </mi>
    <mo lspace="0" rspace="0">
      ′
    </mo>
  </msup></math>, then <math display="inline">
  <mi mathvariant="normal">
    Γ
  </mi>
  <mo lspace="0.278em" rspace="0.278em">
    ⊢
  </mo>
  <msup>
    <mi>
      L
    </mi>
    <mo lspace="0" rspace="0">
      ′
    </mo>
  </msup>
  <mo lspace="0.278em" rspace="0.278em">
    :
  </mo>
  <mi>
    ρ
  </mi></math>. Proof can be done by inducting the one basic and three compatibility cases of beta-reduction.</p>
  <p>Finally, one can prove that there are no infinite reduction sequences in <math display="inline">
  <mi>
    λ
  </mi>
  <mo lspace="0.111em" rspace="0">
    →
  </mo></math>, or every legal term is strongly normalization. This is the <em>String Normalization Theorem</em> or
  <em>Termination Theorem</em>.</p>
</body>
</html>
