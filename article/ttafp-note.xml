<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type='text/xsl' href='/build/web.xsl'?>

<rsml version="1.0" language="en"
      xmlns="https://kekkan.org/RsML">
  <meta>
    <title>Type Theory and Formal Proof</title>
    <subtitle>Some Notes Taken While Reading</subtitle>
    <author>Jing Huang</author>
    <date>
      <year>2024</year>
      <month>--08</month>
      <day>---18</day>
    </date>
    <abstract>These notes are based on the book <emphasize>Type Theory and Formal Proof</emphasize>
    by Rob Nederpelt and Herman Geuvers.</abstract>
  </meta>

  <unit role="chapter">
    <heading>Untyped Lambda Calculus</heading>
    <paragraph><emphasize>Lambda calculus</emphasize> encapsulates a formation of the basic aspects of functions.
    Untyped lambda calculus means we do not consider the types in this chapter.</paragraph>

    <unit role="section">
      <heading>Constriction Principles</heading>
      <list type="itemize">
        <item><emphasize>Abstraction</emphasize>: From an expression <math>M</math> and a variable <math>x</math>
        we can construct a new expression <math>\lambda x.M</math>. We call this the abstraction of <math>x</math>
        over <math>M</math>.</item>
        <item><emphasize>Application</emphasize>: From expressions <math>M</math> and <math>N</math> we can construct
        expression <math>MN</math>. We call this application of <math>M</math> to <math>N</math>.</item>
      </list>
    </unit>

    <unit role="section">
      <heading>Lambda Terms</heading>
      <paragraph>Expressions in the lambda calculus are called <emphasize>lambda terms</emphasize>. We assume the
      existence of an infinite set <math>V=\{x,y,z,\ldots\}</math> of so-called <emphasize>variables</emphasize>
      while the below inductive definition establishes how the set <math>\Lambda</math> of all lambda terms are
      constructed:</paragraph>
      <list type="enumerate">
        <item><emphasize>Variable</emphasize>: If <math>u\in V</math>, then <math>u\in\Lambda</math>.</item>
        <item><emphasize>Application</emphasize>: If <math>M\ \text{and}\ N\in\Lambda</math>, then
        <math>(MN)\in\Lambda</math>.</item>
        <item><emphasize>Abstraction</emphasize>: If <math>u\in V</math> and <math>M\in\Lambda</math>, then
        <math>(\lambda u.M)\in\Lambda</math>.</item>
      </list>
      <paragraph>An <emphasize>inductive definition</emphasize> of <math>\Lambda</math> means that the above definitions
      are the only ways to construct elements of <math>\Lambda</math>. An alternative and shorter way is to define
      <math>\Lambda</math> via <emphasize>abstract syntax</emphasize>:</paragraph>
      <math>\Lambda=V|(\Lambda\Lambda)|(\lambda V.\Lambda).</math>
      <paragraph>The <emphasize>syntactical identity</emphasize> of two lambda terms can be denoted with the symbol
      <math>\equiv</math>.</paragraph>
      <paragraph>The <emphasize>subterms</emphasize> of a given lambda term form a
      <emphasize>multiset</emphasize>:</paragraph>
      <list type="enumerate">
        <item><emphasize>Basis</emphasize>: <math>\texttt{sub}(x)=x</math>, for each <math>x\in V</math>.</item>
        <item><emphasize>Application</emphasize>: <math>\texttt{sub}((MN))=\texttt{sub}(M)\cup\texttt{sub}(N)\cup\{(MN)\}</math>.</item>
        <item><emphasize>Abstraction</emphasize>: <math>\texttt{sub}((\lambda x.M))=\texttt{sub}(M)\cup\{(\lambda x.M)\}</math>.</item>
      </list>
      <paragraph>They follow <emphasize>reflexivity</emphasize> and <emphasize>transitivity</emphasize>. A proper
      subterm of <math>M</math> is <math>L</math> if <math>L\not\equiv M</math>.</paragraph>
      <paragraph>The expression have the following precedence and associativity:</paragraph>
      <list type="itemize">
        <item>Parentheses in an outermost position may be omitted.</item>
        <item>Application is <emphasize>left-associative</emphasize>.</item>
        <item>Application takes precedence over abstraction.</item>
        <item>Successive abstractions may be combined in a <emphasize>right-associative</emphasize> way under one
        <math>\lambda</math>.</item>
      </list>
    </unit>

    <unit role="section">
      <heading>Free and Bound Variables</heading>
      <paragraph>Variable occurrences in a lambda term can be divided into three categories: <emphasize>free</emphasize>
      occurrences, <emphasize>bound</emphasize> occurrences and <emphasize>binding</emphasize> occurrences.</paragraph>
      <paragraph>Binding variables are those occurred immediately after a <math>\lambda</math>. In the construction of
      a lambda term, the single variable and the variables that aren<apostrophe/>t bound by the binding variables are
      free variables. However, during the process of abstraction, an occurrence of <math>x</math> which is free in
      <math>M</math> becomes bound in <math>\lambda x.M</math>; that is, abstraction of <math>x</math> over <math>M</math>
      binds all free occurrences of <math>X</math> in <math>M</math>.</paragraph>
      <paragraph>Then we have the following recursive rule, in which <math>\texttt{fv}(L)</math> denotes the set of free variables
      in the lambda term <math>L</math>.</paragraph>
      <list type="enumerate">
        <item><emphasize>Variable</emphasize>: <math>\texttt{fv}(x)=\{x\}</math>.</item>
        <item><emphasize>Application</emphasize>: <math>\texttt{fv}(MN)=\texttt{fv}(M)\cup\texttt{fv}(N)</math>.</item>
        <item><emphasize>Abstract</emphasize>: <math>\texttt{fv}(\lambda x.M)=\texttt{fv}(M)\backslash\{x\}</math>.</item>
      </list>
      <paragraph>The lambda term is <emphasize>closed</emphasize> if <math>\texttt{fv}(M)=\emptyset</math>. A closed set is also called
      a <emphasize>combinator</emphasize>. The set of all closed lambda terms is denoted by <math>\Lambda^0</math>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Alpha Conversation</heading>
      <paragraph>Functions in the lambda notation have the property that the <emphasize>name</emphasize> of the binding variable
      is not essential; the name is only used to express the transformation or procedure from input to output. Thus the relation
      <emphasize>alpha conversation</emphasize> or <emphasize>alpha equivalence</emphasize> is defined to describe this process
      formally. It<apostrophe/>s based on the possibility of renaming binding (and bound) variables.</paragraph>
      <paragraph><math>M^{x\rightarrow y}</math> denote the result of replacing every free occurrence of <math>x</math> in
      <math>M</math> by <math>y</math>. The relation <math>\lambda x.M=_\alpha\lambda y.M^{x\rightarrow y}</math> is called
      <emphasize>renaming</emphasize>.</paragraph>
      <paragraph>In the renaming of <math>\lambda x.M</math> to <math>\lambda y.M^{x\rightarrow y}</math>, it is prevented that
      the <emphasize>new</emphasize> binding variable <math>y</math> binds <emphasize>old</emphasize> free <math>y</math>s;
      and that any <emphasize>old</emphasize> binding <math>y</math> binds a <emphasize>new</emphasize> <math>y</math>.</paragraph>
      <paragraph>Alpha conversation follows <emphasize>compatibility</emphasize>, <emphasize>reflectivity</emphasize>,
      <emphasize>symmetry</emphasize> and <emphasize>transitivity</emphasize>. If <math>M</math> and <math>N</math> are said to be
      <emphasize>alpha convertible</emphasize> or <emphasize>alpha equivalent</emphasize>, then <math>M</math> is called an
      <emphasize>alpha variant</emphasize> of <math>N</math>.</paragraph>
      <paragraph>We can abstract from the names of the bound (and binding) variables, by considering lambda terms <emphasize>modulo
      alpha equivalence</emphasize>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Beta Reduction</heading>
      <list type="enumerate">
        <item><emphasize>Basis</emphasize>: <math>(\lambda x.M)N\rightarrow_\beta M[x:=N]</math>.</item>
        <item><emphasize>Compatibility</emphasize>: If <math>M\rightarrow_\beta N</math>, then <math>ML\rightarrow_\beta NL</math>,
        <math>LM\rightarrow_\beta NL</math> and <math>\lambda x.M\rightarrow_\beta \lambda x.N</math>.</item>
      </list>
      <paragraph>The suffix <math>[x:=N]</math> not in lambda terms, are meant to be <emphasize>meta-notation</emphasize> called
      substitution, which follow:</paragraph>
      <list type="itemize">
        <item><math>x[x:=N]\equiv N</math>, <math>y[x:=N]\equiv y</math> if <math>x\not\equiv y</math>.</item>
        <item><math>(PQ)[x:=N]\equiv(P[x:=N])(Q[x:=N])</math>.</item>
        <item><math>(\lambda y.P)[x:=N]\equiv\lambda z.(P^{y\rightarrow z}[x:=N])</math>, if <math>\lambda z.P^{y\rightarrow z}</math>
        is an alpha variant of <math>\lambda y.P</math> such that <math>z\notin\texttt{fv}(N)</math>.</item>
      </list>
      <paragraph>The subterm of the form <math>(\lambda x.M)N</math> is called a <emphasize>redex</emphasize> (from reducible
      expression) and subterm <math>M[x:=N]</math> is called the <emphasize>contractum</emphasize> (of the redex).</paragraph>
      <paragraph>Note that in general, the substitutions <math>M[x:=N][y:=L]</math> does not describe the same lambda term as
      <math>M[y:=L][x:=N]</math> because of the left associativity
      (<math>M[x:=N][y:=L]\equiv M[y:=L][x:=N[y:=L]]\land x\notin\texttt{fv}(L)</math>).</paragraph>
      <paragraph>We define the relation <math>\rightarrow_\beta</math> to be one-step beta reduction since one redex is replaced
      by its contractum. The further beta reduction performed after the one-step reduction can be defined using
      <math>\twoheadrightarrow_\beta</math> which generally take zero or more step. We can prove that
      <math>\twoheadrightarrow_\beta</math> is <emphasize>reflective</emphasize> and <emphasize>transitive</emphasize>.</paragraph>
      <paragraph>Similar to alpha conversation, we can define <emphasize>beta conversation</emphasize> or
      <emphasize>beta equivalence</emphasize>. If <math>M=_\beta N</math> and there is an <math>n\geq 0</math> and there are
      terms <math>M_0</math> or <math>M_n</math> such that <math>M_0\equiv M</math>, <math>M_n\equiv N</math> for all
      <math>i</math> such that <math>0\leq i&lt;n</math>:</paragraph>
      <math>M_i\rightarrow_\beta M_{i+1}\lor M_{i+1}\rightarrow_\beta M_i.</math>
      <paragraph><math>\twoheadrightarrow_\beta</math> extends <math>\rightarrow_\beta</math> to multi-steps, while
      <math>=_\beta</math> further extends <math>\twoheadrightarrow_\beta</math> in both directions. Thus <math>=_\beta</math> is
      <emphasize>reflective</emphasize>, <emphasize>symmetric</emphasize> and <emphasize>transitive</emphasize>.</paragraph>
      <list type="itemize">
        <item><math>M</math> is in <emphasize>beta normal</emphasize> form if <math>M</math> does not contain any redex.</item>
        <item><math>M</math> is <emphasize>beta normalizing</emphasize> if there is an <math>N</math> in beta normal form
        such that <math>M=_\beta N</math>.</item>
      </list>
      <paragraph>A <emphasize>reduction path</emphasize> from <math>M</math> is an infinite or finite sequence <math>N_0,N_1,N_2,\ldots</math>
      that is connected using one-step beta reduction that starts from <math>M</math>.</paragraph>
      <list type="itemize">
        <item><math>M</math> is <emphasize>weakly normalizing</emphasize> if there is an <math>N</math> in the beta normal form such that
        <math>M\twoheadrightarrow_\beta N</math>. (<emphasize>One of</emphasize> the reduction path leads to an outcome.)</item>
        <item><math>M</math> is <emphasize>strongly normalizing</emphasize> if there are no infinite reduction paths starting from <math>M</math>.
        (<emphasize>Each</emphasize> reduction path leads to an outcome.)</item>
      </list>
      <paragraph>Suppose that for a given lambda term <math>M</math>, we have <math>M\twoheadrightarrow_\beta N_i</math> and
      <math>M\twoheadrightarrow_\beta N_2</math>, then there is a lambda term <math>N_3</math> such that
      <math>N_1\twoheadrightarrow_\beta N_3</math> and <math>N_2\twoheadrightarrow_\beta N_3</math>. This is the
      <emphasize>Church-Rosser Theorem</emphasize>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Fixed Point Theorem</heading>
      <paragraph>Every lambda term <math>L</math> has a <emphasize>fixed point</emphasize>, which can be constructed using a <emphasize>fixed point
      combinator</emphasize>. One instance is:</paragraph>
      <math>Y\equiv\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)).</math>
      <paragraph>Then we have <math>YL</math> which is a fixed point of <math>L</math>, since <math>L(YL)=_\beta YL</math>, which can be shown as
      follows:</paragraph>
      <math>\begin{align}
      YL&amp;\rightarrow_\beta(\lambda x.L(xx))(\lambda x.L(xx))\\
      &amp;\rightarrow_\beta L((\lambda x.L(xx))(\lambda x.L(xx)))\\
      &amp;=_\beta L(YL).
      \end{align}</math>
    </unit>
  </unit>

  <unit role="chapter">
    <heading>Simply Typed Lambda Calculus</heading>
    <paragraph>In order to get a firmer hold on the desired behavior of functions, we introduce <emphasize>types</emphasize>. Functions are
    been classified to a certain collection, and certain restrictions on the input values are given.</paragraph>
    <paragraph>The <emphasize>simple types</emphasize> introduced in this chapter prevents the anomalies but are also in several senses
    too restrictive. We will enlarge the expressivity of the system in subsequent chapters.</paragraph>

    <unit role="section">
      <heading>Simple Types</heading>
      <paragraph>We first define an infinite set of type <emphasize>variables</emphasize>
      <math>\mathbb{V}=\{\alpha,\beta,\gamma,\ldots\}.</math> and then define the set of simple types <math>\mathbb{T}</math>:</paragraph>
      <list type="enumerate">
        <item><emphasize>Type variable</emphasize>: If <math>\alpha\in\mathbb{V}</math>, then <math>\alpha\in\mathbb{T}</math>.</item>
        <item><emphasize>Arrow type</emphasize>: If <math>\sigma,\tau\in\mathbb{T}</math>, then
        <math>(\sigma\rightarrow\tau)\in\mathbb{T}</math>.</item>
      </list>
      <paragraph>It can be expressed using abstract syntax as <math>\mathbb{T}=\mathbb{V}|\mathbb{T}\rightarrow\mathbb{T}</math>.</paragraph>
      <paragraph>The Greek letters <math>\alpha,\beta,\gamma,\ldots</math> and variants are used for type variables belonging to
      <math>\mathbb{V}</math>. Arbitrary simple types are denoted using <math>\sigma,\tau,\ldots</math>. Their outermost parentheses may be
      <emphasize>omitted</emphasize> and for arrow-types, they are <emphasize>right-associative</emphasize>.</paragraph>
      <paragraph>Type variables are abstract representations of <emphasize>basic types</emphasize>, such as <math>nat</math> for natural numbers or
      <math>list</math> for lists. Arrow types represent <emphasize>function types</emphasize>, such as <math>nat\rightarrow real</math> which
      abstracts a function which input is a natural number and the returned result is a real number.</paragraph>
      <paragraph>We also have <emphasize>statements</emphasize> which allow us to express something like <quote>term <math>M</math> has type
      <math>\sigma</math></quote> in the form <math>M:\sigma</math>. We assume we have infinitude of variables available for each type
      <math>\sigma</math>, thus we assume that each variable <math>x</math> has a unique type: if <math>x:\sigma</math> and <math>x:\tau</math>,
      then <math>\sigma\equiv\tau</math>.</paragraph>
      <paragraph>By adding typing to the basic construction principles of lambda calculus, we have:</paragraph>
      <list type="enumerate">
        <item><emphasize>Application</emphasize>: If <math>M:\sigma\rightarrow\tau</math> and <math>N:\sigma</math>, then
        <math>MN:\tau</math>.</item>
        <item><emphasize>Abstraction</emphasize>: If <math>x:\sigma</math> and <math>M:\tau</math>, then
        <math>\lambda x.M:\sigma\rightarrow\tau</math>.</item>
      </list>
      <paragraph>There are two <emphasize>side conditions</emphasize> which have to be satisfied in the typing of an application <math>MN</math>:
      the left-hand side <math>M</math> of the application must have a function type <math>\sigma\rightarrow\tau</math> while the right-hand side
      <math>N</math> of the application must match with the input type <math>\sigma</math>; the output type will then be <math>\tau</math>.
      For abstraction <math>\lambda x.M</math>, we just need the types of <math>x</math> and <math>M</math>.</paragraph>
      <paragraph>A term <math>M</math> is called <emphasize>typable</emphasize> if there is a type <math>\sigma</math> such that
      <math>M:\sigma</math>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Church and Curry Typing</heading>
      <paragraph>To type a lambda term, we should first type its variables. We can give types to variables in two ways:</paragraph>
      <list type="enumerate">
        <item><emphasize>Typing à la Church</emphasize>: also called <emphasize>explicit typing</emphasize>, that we prescribe a (unique) type
        for each variable upon its introduction.</item>
        <item><emphasize>Typing à la Curry</emphasize>: also called <emphasize>implicit typing</emphasize>, which type is left open to some extent.
        We find typable terms by a search process, which may involve guesses for the types of the variables.</item>
      </list>
      <paragraph>We denote the types of bound variables immediately after their introduction following a <math>\lambda</math> while the types of
      free variables are given in a so-called <emphasize>context</emphasize> (<emphasize>basis</emphasize>):</paragraph>
      <math>x:\alpha\rightarrow\alpha,y:(\alpha\rightarrow\alpha)\rightarrow\beta\vdash(\lambda z:\beta.\lambda u:\gamma.z)(yx):
      \gamma\rightarrow\beta.</math>
    </unit>

    <unit role="section">
      <heading>Derivation Rules for Church<apostrophe/>s <math>\lambda_\rightarrow</math></heading>
      <paragraph>The definition of lambda terms have to be modified to incorporate type information. This new set of pre-typed
      <math>\Lambda_\mathbb{T}</math> is defined by
      <math>\Lambda_\mathbb{T}=V|(\Lambda_\mathbb{T}\Lambda_\mathbb{T})|(\lambda V:\mathbb{T}.\Lambda_\mathbb{T})</math>.</paragraph>
      <paragraph>A <emphasize>judgment</emphasize> has the form <math>\Gamma\vdash M:\sigma</math>, with <math>\Gamma</math> a context and
      <math>M:\sigma</math> a statement.</paragraph>
      <list type="enumerate">
        <item><emphasize>Statement</emphasize>: <math>M:\sigma</math>, where <math>M\in\Lambda_\mathbb{T}</math> and
        <math>\sigma\in\mathbb{T}</math>.</item>
        <item><emphasize>Declaration</emphasize>: a statement with a variable as subject.</item>
        <item><emphasize>Context</emphasize>: a list of declarations with different subjects.</item>
      </list>
      <paragraph>Below we give three <emphasize>derivation rules</emphasize> to form a so-called <emphasize>derivation system</emphasize> for
      Church<apostrophe/>s <math>\lambda_\rightarrow</math> in the <emphasize>premiss-conclusion</emphasize> format.</paragraph>
      <math>\begin{array}{lc}
      (var)&amp;\displaystyle\gamma\vdash x:\sigma\ \text{if}\ x:\sigma\in\Gamma.\\
      (appl)&amp;\displaystyle\frac{\Gamma\vdash M:\sigma\rightarrow\tau\quad\gamma\vdash N:\sigma}{\Gamma\vdash MN:\tau}.\\
      (abst)&amp;\displaystyle\frac{\gamma,x:\sigma\vdash M:\tau}{\Gamma\vdash\lambda x:\sigma,M:\sigma\rightarrow\tau}.
      \end{array}</math>
      <paragraph>A pre-typed term <math>\lambda_\rightarrow</math> is called <emphasize>legal</emphasize> if there exist context
      <math>\Gamma</math> and type <math>\rho</math> such that <math>\Gamma\vdash M:\rho</math>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Well-Typedness in <math>\lambda_\rightarrow</math></heading>
      <paragraph>This is one of the three problems connected with judgments in type theory: to find an appropriate context and type if the term
      is indeed legal.</paragraph>
      <paragraph>For example, we want to show <math>M\equiv\lambda y:\alpha\rightarrow\beta.\lambda z:\alpha.yz</math> is valid. Hence, our task
      is to find a type <math>\rho</math> such that <math>\Gamma\vdash M:\rho</math>. First we determine the context <math>\Gamma</math> which
      <math>\Gamma\equiv\emptyset</math> suffices since there are no free variables in <math>M</math>. Then we need to find
      <math>\rho</math>.</paragraph>
      <math>\begin{array}{cl}
      \displaystyle\frac{y:\alpha\rightarrow\beta\quad z:\alpha}{y:\alpha\rightarrow\beta,z:\alpha\vdash yz:\beta}&amp;(appl)\\
      \displaystyle\frac{y:\alpha\rightarrow\beta,z:\alpha\vdash yz:\beta}{y:\alpha\rightarrow\beta\vdash
      \lambda z:\alpha.yz:\alpha\rightarrow\beta}&amp;(abst)\\
      \displaystyle\frac{y:\alpha\rightarrow\beta\vdash\lambda z:\alpha.yz:\alpha\rightarrow\beta}
      {\lambda y:\alpha\rightarrow\beta.\lambda z:\alpha.yz:(\alpha\rightarrow\beta)\rightarrow(\alpha\rightarrow\beta)}&amp;(abst)
      \end{array}</math>
      <paragraph>Thus we can conclude that <math>\lambda y.\alpha\rightarrow\beta.\lambda z:\alpha.yz</math> is valid since we find
      <math>\rho</math> which is <math>(\alpha\rightarrow\beta)\rightarrow(\alpha\rightarrow\beta)</math>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Type Checking in <math>\lambda_\rightarrow</math></heading>
      <paragraph>The name type checking is straightforward, it means to check the validity of a full judgment.</paragraph>
      <paragraph>As an example, we can construct a derivation for
      <math>x:\alpha\rightarrow\alpha,y:(\alpha\rightarrow\alpha)\rightarrow\beta
      \vdash(\lambda z:\beta.\lambda u:\gamma.z)(yz):\gamma\rightarrow\beta</math>:</paragraph>
      <math>\begin{array}{cl}
      \displaystyle\frac{x:\alpha\rightarrow\alpha\quad y:(\alpha\rightarrow\alpha)\rightarrow\beta}
      {x:\alpha\rightarrow\alpha,y:(\alpha\rightarrow\alpha)\rightarrow\beta\vdash yx:\beta}\quad
      \frac{z:\beta\quad u:\gamma}{z:\beta,u:\gamma\vdash\lambda z:\beta.\lambda u:\gamma.z:\beta\rightarrow\gamma\rightarrow\beta}&amp;(appl,abst)\\
      \displaystyle\frac{x:\alpha\rightarrow\alpha,y:(\alpha\rightarrow\alpha)\rightarrow\beta\vdash yx:\beta\>\quad\>
      z:\beta,u:\gamma\vdash\lambda z:\beta.\lambda u:\gamma.z:\beta\rightarrow\gamma\rightarrow\beta}
      {(\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma\rightarrow\beta}&amp;(appl)
      \end{array}</math>
      <paragraph>Hence we have succeeded in giving a proper deviation of the judgment.</paragraph>
    </unit>

    <unit role="section">
      <heading>Term Finding in <math>\lambda_\rightarrow</math></heading>
      <paragraph>This section presents the third of the general problem in type theory, namely to find an appropriate term of a certain type,
      in a certain context. A term which belongs to a certain type is called an <emphasize>inhabitant</emphasize> of that type.</paragraph>
      <paragraph>To find an inhabitant of a certain type, we can think of the type as <emphasize>proposition</emphasize>, while each inhabitant
      codes a <emphasize>proof</emphasize> of this proposition.</paragraph>
      <paragraph>For instance, to find the term of <math>A\rightarrow B\rightarrow A</math>, we can follow:</paragraph>
      <list type="enumerate">
        <item>Assume that <math>x</math> is a proof of proposition <math>A</math>.</item>
        <item>Also assume that <math>y</math> is a proof of proposition <math>B</math>.</item>
        <item>Then <math>x</math> is still a proof of <math>A</math>.</item>
        <item>So the function mapping <math>y</math> to <math>x</math> sends a proof of <math>B</math> to a proof of <math>A</math>, i.e.,
        <math>\lambda y:B.x</math> proves the implication <math>B\rightarrow A</math>.</item>
        <item>Consequently, <math>\lambda z:A.\lambda y:B.x</math> proves <math>A\rightarrow B\rightarrow A</math>.</item>
      </list>
      <paragraph>The above process is generally called the <emphasize>PAT-interpretation</emphasize>, where PAT means both
      <quote>propositions-as-types</quote> and <quote>proofs-as-terms</quote>.</paragraph>
    </unit>

    <unit role="section">
      <heading>General Properties of <math>\lambda_\rightarrow</math></heading>
      <paragraph>We give a number of definitions about context below:</paragraph>
      <list type="enumerate">
        <item>If <math>\Gamma\equiv x_1:\sigma_1,\ldots,x_n:\sigma_n</math>, then the <emphasize>domain</emphasize> of <math>\Gamma</math>
        or <math>\mathcal D(\Gamma)</math> is the list <math>(x_1,\ldots,x_n)</math>.</item>
        <item>Context <math>\Gamma'</math> is a <emphasize>subcontext</emphasize> of context <math>\Gamma</math>, or
        <math>\Gamma'\subseteq\Gamma</math>, if all declarations occurring in <math>\Gamma'</math> also occur in <math>\Gamma</math>,
        in the same order.</item>
        <item>Context <math>\Gamma'</math> is a <emphasize>permutation</emphasize> of context <math>\Gamma</math>, if all declarations
        in <math>\Gamma'</math> also occur in <math>\Gamma</math>, and vice versa.</item>
        <item>If <math>\Gamma</math> is a context and <math>\Phi</math> is a set of variables, then the <emphasize>projection</emphasize> of
        <math>\Gamma</math> on <math>\Phi</math>, or <math>\Gamma\upharpoonright\Phi</math>, is the subcontext <math>\Gamma'</math> of
        <math>\Gamma</math> with <math>\mathcal D(\Gamma')=\mathcal D(\Gamma)\cap\Phi</math>.</item>
      </list>
      <paragraph>An important property concerning the free variables occurring in a judgment is that if <math>\Gamma\vdash L:\sigma</math>,
      then <math>\texttt{fv}(L)\subseteq\mathcal D(\Gamma)</math>. This can be proved by induction on the deviation of the judgment
      <math>\mathcal J\equiv\Gamma\vdash L:\sigma</math>.</paragraph>
      <paragraph>We continue with three other properties which are trivial and can also be proved by induction.</paragraph>
      <list type="enumerate">
        <item><emphasize>Thinning</emphasize>: Let <math>\Gamma'</math> and <math>\Gamma''</math> be contexts such that
        <math>\Gamma'\subseteq\Gamma''</math>. If <math>\Gamma'\vdash M:\sigma</math>, then also <math>\Gamma''\vdash M:\sigma</math>.</item>
        <item><emphasize>Condensing</emphasize>: If <math>\Gamma\vdash M:\sigma</math>, then also
        <math>\Gamma\upharpoonright\texttt{fv}(M)\vdash M:\sigma</math>.</item>
        <item><emphasize>Permutation</emphasize>: If <math>\Gamma\vdash M:\sigma</math>, and <math>\Gamma'</math> is a permutation of
        <math>\Gamma</math>, then <math>\Gamma'</math> is also a context and moreover, <math>\Gamma'\vdash M:\sigma</math>.</item>
      </list>
      <paragraph>The <emphasize>Generation Lemma</emphasize>, which says precisely how a certain judgment can be generated, is shown
      below:</paragraph>
      <list type="enumerate">
        <item>If <math>\Gamma\vdash x:\sigma</math>, then <math>x:\sigma\in\Gamma</math>.</item>
        <item>If <math>\Gamma\vdash MN:\tau</math>, then there is a type <math>\sigma</math> such that
        <math>\Gamma\vdash M:\sigma\rightarrow\tau</math> and <math>\Gamma\vdash N:\sigma</math>.</item>
        <item>If <math>\Gamma\vdash\lambda x:\sigma.M:\rho</math>, then there is <math>\tau</math> such that
        <math>\Gamma,x:\sigma\vdash M:\tau</math> and <math>\rho\equiv\sigma\rightarrow\tau</math>.</item>
      </list>
      <paragraph>It<apostrophe/>s obvious that, in order to build a legal term, its subterms should be legal too. This is the
      <emphasize>Subterm Lemma</emphasize>.</paragraph>
      <paragraph>Another important property which applies for Church<apostrophe/>s <math>\lambda_\rightarrow</math> is that, a term may have
      <emphasize>at most one</emphasize> type. This ensures that the type, if exists, must be unique. Therefore we also have the
      <emphasize>uniqueness of types</emphasize>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Reduction and <math>\lambda_\rightarrow</math></heading>
      <paragraph>In order to be able to treat substitution, an operation at the heart of beta reduction, in <math>\lambda_\rightarrow</math>,
      we have to append type information. We then have the <emphasize>Substitution Lemma</emphasize>: assume
      <math>\Gamma',x:\sigma,\Gamma''\vdash M:\tau</math> and <math>\Gamma'\vdash N:\sigma</math>; then
      <math>\Gamma',\Gamma''\vdash M[x:=N]:\tau</math>. This means that if we substitute all occurrences of context variable by a term of the
      same type, the result type is unchanged which is intuitively understandable.</paragraph>
      <paragraph>We also have to adjust the definition for beta reduction to the (pre-typed) terms of <math>\Lambda_\mathbb{T}</math>:</paragraph>
      <list type="enumerate">
        <item><emphasize>Basis</emphasize>: <math>(\lambda x:\sigma.M)N\rightarrow_\beta M[x:=N]</math>.</item>
        <item><emphasize>Compatibility</emphasize>: If <math>M\rightarrow_\beta N</math>, then <math>ML\rightarrow_\beta NL</math>,
        <math>LM\rightarrow_\beta NL</math> and <math>\lambda x:\tau.M\rightarrow_\beta \lambda x:\tau.N</math>.</item>
      </list>
      <paragraph>The Church-Rosser Theorem is still valid as types clearly play no role in the reduction process.</paragraph>
      <paragraph>The <emphasize>Subject Reduction</emphasize> states that beta reduction does not affect typability, and even does not change
      the term<apostrophe/>s type: if <math>\Gamma\vdash L:\rho</math> and if <math>L\twoheadrightarrow_\beta L'</math>, then
      <math>\Gamma\vdash L':\rho</math>. Proof can be done by inducting the one basic and three compatibility cases of beta reduction.</paragraph>
      <paragraph>Finally, one can prove that there are no infinite reduction sequences in <math>\lambda_\rightarrow</math>, or every legal
      term is strongly normalization. This is the <emphasize>String Normalization Theorem</emphasize> or
      <emphasize>Termination Theorem</emphasize>.</paragraph>
    </unit>
  </unit>

  <unit role="chapter">
    <heading>Second Order Typed Lambda Calculus</heading>
    <paragraph>In Church<apostrophe/>s <math>\lambda_\rightarrow</math>, we only encounter abstraction and application on the term level,
    which is <emphasize>first order</emphasize>, as abstraction and application are over <emphasize>terms</emphasize>. In the present chapter,
    <emphasize>second order</emphasize> operations, or terms depending on types, are introduced.</paragraph>
    <paragraph>This is called the <emphasize>second order lambda calculus</emphasize>, written as <math>\lambda2</math> for short.</paragraph>

    <unit role="section">
      <heading><math>\Pi</math> Types</heading>
      <paragraph>To construct a function that can handle terms of different types, we can consider an <emphasize>arbitrary</emphasize>
      type, and use this type as another abstraction for our function <math>\lambda\alpha:*.\lambda x:\alpha.x</math>.</paragraph>
      <paragraph>This function receives a type variable <math>\alpha</math>, while the <math>*</math> symbol denotes <emphasize>the type of
      all types</emphasize>. The function acts as a term depending on a type, thus is second ordered or
      <emphasize>polymorphic</emphasize>.</paragraph>
      <paragraph>To type this polymorphic term, we introduce a new <emphasize>binder</emphasize>, the <math>\Pi</math> binder. We can then express
      the type of the polymorphic function created earlier as <math>\Pi\alpha:*.\alpha\rightarrow\alpha</math>.</paragraph>
      <paragraph>By an obvious extension of the alpha conversation, we obtain:</paragraph>
      <math>\Pi\alpha:*.\alpha\rightarrow\alpha\equiv\Pi\beta:*.\beta\rightarrow\beta.</math>
    </unit>

    <unit role="section">
      <heading>Second Order Abstraction and Application Rules</heading>
      <paragraph>Since we allow second order abstraction, second order application and <math>\Pi</math> types, our derivation system for
      <math>\lambda_\rightarrow</math> has to be extended.</paragraph>
      <math>\begin{array}{lc}
      (appl_2)&amp;\displaystyle\frac{\Gamma\vdash M:\Pi\alpha:*.A\quad\Gamma\vdash B:*}{\Gamma\vdash MB:A[\alpha:=B]}.\\
      (abst_2)&amp;\displaystyle\frac{\Gamma,\alpha:*\vdash M:A}{\Gamma\vdash\lambda\alpha:*.M:\Pi\alpha:*.A}.
      \end{array}</math>
      <paragraph>The second order application rule is intuitive, that two types of arbitrary type can be interchanged. This abstraction rule
      also corresponds to our expectations, as presented in the previous section where the <math>\Pi</math> types are introduced.</paragraph>
    </unit>

    <unit role="section">
      <heading>The System <math>\lambda2</math></heading>
      <paragraph>To describe the complete system, we have to first extend our definition of types. The abstract syntax for <math>\lambda2</math>
      types is <math>\mathbb{T}_2=\mathbb{V}|(\mathbb{T}_2\rightarrow\mathbb{T}_2)|(\Pi\mathbb{V}:*.\mathbb{T}_2)</math> while
      <math>\mathbb{V}</math> is the set of type variables.</paragraph>
      <paragraph>Then we extend our set of pre-typed lambda terms so that second order abstraction and application are allowed:</paragraph>
      <math>\Lambda_{\mathbb{T}_2}=V|(\Lambda_{\mathbb{T}_2}\Lambda_{\mathbb{T}_2})|(\Lambda_{\mathbb{T}_2}\mathbb{T}_2)|
      (\lambda V:\mathbb{T}_2.\Lambda_{\mathbb{T}_2})|(\lambda\mathbb{V}:*.\Lambda_{\mathbb{T}_2}).</math>
      <paragraph>Note that now we have two classes of variables: object variables <math>V</math> and type variables <math>\mathbb{V}</math>.
      We also have first order application <math>(\Lambda_{\mathbb{T}_2}\Lambda_{\mathbb{T}_2})</math> and second order application
      <math>(\Lambda_{\mathbb{T}_2}\mathbb{T}_2)</math> as well as first order abstraction
      <math>(\lambda V:\mathbb{T}_2.\Lambda_{\mathbb{T}_2})</math> from object variables and second order abstraction
      <math>(\lambda\mathbb{V}:*.\Lambda_{\mathbb{T}_2})</math>.</paragraph>
      <paragraph>The convention is similar to that in untyped and simply typed lambda calculus:</paragraph>
      <list type="itemize">
        <item>Outer parentheses may be omitted.</item>
        <item>Application is left-associative.</item>
        <item>Application and <math>\rightarrow</math> takes precedence over both <math>\lambda</math> and <math>\Pi</math> abstraction.</item>
        <item>Successive <math>\lambda</math> or <math>\Pi</math> abstractions concerning the same types may be combined in a right-associative
        way.</item>
        <item>Arrow types are denoted in a right-associative way.</item>
      </list>
      <paragraph>The notation of declaration should as well be extended to allow second order declarations:</paragraph>
      <list type="enumerate">
        <item><emphasize>Statement</emphasize>: Either of the form <math>M:\sigma</math>, where <math>M\in\Lambda_{\mathbb{T}_2}</math> and
        <math>\sigma\in\mathbb{T}_2</math>, or of the form <math>\sigma:*</math>, where <math>\sigma\in\mathbb{T}_2</math>.</item>
        <item><emphasize>Declaration</emphasize>: A statement with a <emphasize>term variable</emphasize> or a <emphasize>type variable</emphasize>
        as subject.</item>
      </list>
      <paragraph>The rule that all variables must be declared before they can be used motivates the following recursive definition of the
      <math>\lambda2</math> context, which the new definition of the <emphasize>domain</emphasize> of a context is combined:</paragraph>
      <list type="enumerate">
        <item><math>\emptyset</math> is a <math>\lambda2</math> context. Its domain is the empty list.</item>
        <item>If <math>\Gamma</math> is a <math>\lambda2</math> context, <math>\alpha\in\mathbb{V}</math> and
        <math>\alpha\notin\texttt{dom}(\Gamma)</math>, then <math>\Gamma,\alpha:*</math> is a <math>\lambda2</math> context.
        And <math>\texttt{dom}(\Gamma,\alpha:*)=(\texttt{dom}(\Gamma),\alpha)</math>.</item>
        <item>If <math>\Gamma</math> is a <math>\lambda2</math> context, if <math>\rho\in\mathbb{T}_2</math> such that
        <math>\alpha\in\texttt{dom}(\Gamma)</math> for all free type variants <math>\alpha</math> occurring in <math>\rho</math> and if
        <math>x\notin\texttt{dom}(\Gamma)</math>, then <math>\Gamma,x:\rho</math> is a <math>\lambda2</math> context. And
        <math>\texttt{dom}(\Gamma,x:\rho)=(\texttt{dom}(\Gamma),x)</math>.</item>
      </list>
      <paragraph>Conforming with the new notion of context, we adapt the variable rule and define the <emphasize>formation rule</emphasize>
      which defines a properly formed <math>\lambda2</math> type. We assume <math>\Gamma</math> is a <math>\lambda2</math> context.</paragraph>
      <math>\begin{array}{lc}
      (var)&amp;\displaystyle\frac{x:\sigma\in\Gamma}{\Gamma\vdash x:\sigma}.\\
      (form)&amp;\displaystyle\frac{B\in\mathbb{T}_2\quad\texttt{fv}(B)\in\Gamma}{\Gamma\vdash B:*}.
      \end{array}</math>
      <paragraph>Finally, we define the legality of <math>\lambda2</math>: a term <math>M</math> in <math>\Lambda_{\mathbb{T}_2}</math>
      is called legal if there exists a <math>\lambda2</math> context <math>\Gamma</math> and a type <math>\rho</math> in <math>\mathbb{T}_2</math>
      such that <math>\Gamma\vdash m:\rho</math>.</paragraph>
    </unit>

    <unit role="section">
      <heading>Properties of <math>\lambda2</math></heading>
      <paragraph>The definition of alpha conversion is adapted and extended accommodating <math>\Pi</math> types:</paragraph>
      <list type="enumerate">
        <item><emphasize>Renaming of term variable</emphasize>: <math>\lambda x:\sigma.M=_\alpha\lambda y:\sigma.M^{x\rightarrow y}</math> if
        <math>y\notin \texttt{fv}(M)</math> and <math>y</math> does not occur as a binding variable in <math>M</math>.</item>
        <item><emphasize>Renaming of type variable</emphasize>: <math>\lambda\alpha:*.M=_\alpha\lambda\beta:*.M[\alpha:=\beta]</math>
        if <math>\beta</math> does not occur in <math>M</math> or <math>\Pi\alpha:*.M=_\alpha\Pi\beta:*.M[\alpha:=\beta]</math> if <math>\beta</math>
        does not occur in <math>M</math>.</item>
      </list>
      <paragraph>We also extend the beta reduction in an obvious way matching the extensions of alpha conversation:</paragraph>
      <list type="enumerate">
        <item><emphasize>Basis for first order</emphasize>: <math>(\lambda m:\sigma.M)N\rightarrow_\beta M[x:=N]</math>.</item>
        <item><emphasize>Basis for second order</emphasize>: <math>(\lambda\alpha:*.M)T\rightarrow_\beta M[\alpha:=T]</math>.</item>
      </list>
      <paragraph>Most properties for <math>\lambda_\rightarrow</math> defined in the present chapter still applies, except the
      Permutation Lemma, which holds only if the permuted context is a <math>\lambda2</math> context.</paragraph>
    </unit>
  </unit>
</rsml>
